{"meta":{"title":"Z's blog","subtitle":"","description":"","author":"daiwenzh5","url":"http://daiwenzh5.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-03-03T15:42:09.339Z","updated":"2022-03-03T15:42:09.339Z","comments":true,"path":"404.html","permalink":"http://daiwenzh5.github.io/404.html","excerpt":"404 很抱歉，您访问的页面不存在","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-03-03T15:42:09.339Z","updated":"2022-03-03T15:42:09.339Z","comments":true,"path":"manifest.json","permalink":"http://daiwenzh5.github.io/manifest.json","excerpt":"{\"name\":\"Z's Blog\",\"short_name\":\"Z's Blog\",\"theme_color\":\"#424242\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/images/logos/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/images/logos/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/images/logos/128.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"/images/logos/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/images/logos/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/images/logos/512.png\",\"sizes\":\"511x511\",\"type\":\"image/png\"}],\"splash_pages\":null}","text":"{\"name\":\"Z's Blog\",\"short_name\":\"Z's Blog\",\"theme_color\":\"#424242\",\"background_color\":\"#ffffff\",\"display\":\"standalone\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"/images/logos/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"/images/logos/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"/images/logos/128.png\",\"sizes\":\"128x128\",\"type\":\"image/png\"},{\"src\":\"/images/logos/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"/images/logos/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"/images/logos/512.png\",\"sizes\":\"511x511\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"所有分类","date":"2020-12-21T09:15:25.000Z","updated":"2022-03-03T15:42:09.339Z","comments":true,"path":"categories/index.html","permalink":"http://daiwenzh5.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-12-21T09:15:52.000Z","updated":"2022-03-03T15:42:09.339Z","comments":true,"path":"tags/index.html","permalink":"http://daiwenzh5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RestTemplate 使用","slug":"yuque/RestTemplate 使用","date":"2022-02-27T15:24:11.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2022/02/27/yuque/RestTemplate 使用/","link":"","permalink":"http://daiwenzh5.github.io/2022/02/27/yuque/RestTemplate%20%E4%BD%BF%E7%94%A8/","excerpt":"场景描述restTemplate 是 spring 提供的基于 restful 设计的 http 请求客户端。","text":"场景描述restTemplate 是 spring 提供的基于 restful 设计的 http 请求客户端。 使用介绍配置springboot 默认提供了 restTemplate 相关的 Bean，但也可以通过手动注册同类型的 bean 来自定义一些配置，如通用的请求头，拦截器等。 123456@Beanpublic RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123; RestTemplate restTemplate = new RestTemplate(factory); // 其他设置，如：拦截器、消息处理器等 return restTemplate;&#125; 拦截器一般的会将特定功能的拦截器，注册到独立的 restTemplate bean 中，即设置多个 restTemplate bean（默认同类型下只能存在一个 bean，可以使用包装类，装饰器）。 1234567891011121314// 定义自定义拦截器public class CustomInterceptor implements ClientHttpRequestInterceptor&#123; @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException &#123; // 自定义方法体 ... // 执行完毕后放行请求 return execution.execute(request, body); &#125;&#125;// 添加拦截器restTemplate.getInterceptors().add(new CustomInterceptor()) 自定义消息转换器项目中经常使用 FastJson 替换 Jackson，实际上项目中存在一个 Json 处理工具即可，（Jackson 挺好用的，感觉 Bug 少多了）。 123456789101112131415161718192021222324252627282930313233343536public void setRestTemplate(RestTemplate restTemplate) &#123; // 重新设置了消息转换器集合，通过遍历过滤了原有的 Jackson 处理器，最后添加了 FastJson 处理器 // 也可以直接在原有的 list 中使用 remove 去除，再添加 List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = restTemplate.getMessageConverters(); List&lt;HttpMessageConverter&lt;?&gt;&gt; convertersValid = new ArrayList&lt;&gt;(); for (HttpMessageConverter&lt;?&gt; converter : converters) &#123; if (converter instanceof MappingJackson2HttpMessageConverter || converter instanceof MappingJackson2XmlHttpMessageConverter) &#123; continue; &#125; convertersValid.add(converter); &#125; convertersValid.add(fastJsonHttpMessageConverter()); restTemplate.setMessageConverters(convertersValid);&#125;/** * fastJson 消息转换器 * * @return fastJson 消息转换器 */private FastJsonHttpMessageConverter fastJsonHttpMessageConverter() &#123; List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;&gt;(); mediaTypes.add(MediaType.APPLICATION_JSON); FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat); fastJsonConfig.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); GsonHttpMessageConverter gsonHttpMessageConverter = new GsonHttpMessageConverter(); gsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes); FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); fastConverter.setSupportedMediaTypes(mediaTypes); fastConverter.setFastJsonConfig(fastJsonConfig); return fastConverter;&#125; Get 参数设置使用 restful 占位符，设置方式和 controller 层一致，如： 1234567void testGetParam() &#123; restTemplate.getForObject( &#x27;route?param1=&#123;param1&#125;&amp;param2=&#123;param2&#125;&#x27;, T.class, ...参数 )&#125; ps：当然参数也可以使用 Map List 类型结果对于任意使用 List 的结果集，在泛型类型设置上，使用 T[].class 替代，可以很好的避免 List&lt;?&gt; 无法获取具体类型的问题。当然也可以使用 new ParameterizedTypeReference&lt;List&lt;T&gt;&gt;()&#123;&#125;，但其本身是通过生成匿名类（类中的泛型不会被擦除）的方式来记录泛型信息。使用数组类型无疑更简洁优雅。 自定义 header使用 exchange 方法1234567891011void testExchange() &#123; HttpHeaders requestHeaders = new HttpHeaders(); HttpEntity&lt;UserModel[]&gt; request = new HttpEntity&lt;&gt;(requestHeaders); val result = restTemplate.exchange( &quot;路由&quot;, HttpMethod.GET, request, T[].class, ...参数 ).getBody();&#125; 使用 execute 方法12345678910111213void testExecute() &#123; HttpHeaders requestHeaders = new HttpHeaders(); HttpEntity&lt;UserModel[]&gt; request = new HttpEntity&lt;&gt;(requestHeaders); val requestCallback = restTemplate.httpEntityCallback(request, T[].class); val responseExtractor = restTemplate.responseEntityExtractor(T[].class); val result = restTemplate.execute( &quot;路由&quot;, HttpMethod.GET, requestCallback, responseExtractor, ...参数 );&#125;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"Rest Template","slug":"Spring-Boot/Rest-Template","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/Rest-Template/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"Rest Template","slug":"Rest-Template","permalink":"http://daiwenzh5.github.io/tags/Rest-Template/"},{"name":"Http 请求","slug":"Http-请求","permalink":"http://daiwenzh5.github.io/tags/Http-%E8%AF%B7%E6%B1%82/"},{"name":"Restful","slug":"Restful","permalink":"http://daiwenzh5.github.io/tags/Restful/"}]},{"title":"WebMvc 测试","slug":"yuque/WebMvc 测试","date":"2022-02-26T10:38:31.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2022/02/26/yuque/WebMvc 测试/","link":"","permalink":"http://daiwenzh5.github.io/2022/02/26/yuque/WebMvc%20%E6%B5%8B%E8%AF%95/","excerpt":"场景描述需要对 api 编写测试类，可以采用的方式：","text":"场景描述需要对 api 编写测试类，可以采用的方式： MockMvc RestTemple 但是由于 MockMvc 的结果值是字符串，虽然提供了 jsonPath 方法解析，但是处理过程丧失了面向对象的优雅，可能其对于 controller 层作单元测试，结合 MockBean，应当会更方便，轻量；而在处理完整的 api 测试，使用 restTemplate 通过泛型可以直接获取到结果对象，处理过程更灵活。 注意事项获取端口号ps：使用 RestTemplate 是需要获取端口号的。在启用 @SpringBootTest 时，无法直接从配置文件读取端口号，需要指定 ： 123456@SpringBootTest( classes = SampleApplication.class, // 启用配置文件中定义的端口号 // 也可以通过枚举值切换为随机端口等 webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT) 否则会出现 -1 或 null 的情况，之后可以通过常规的 spring 注入方式，来获取端口号，如： 12345678910// 1. server.port 或 local.server.port@Value(&quot;$&#123;server.port&#125;&quot;)// 2. @Value(&quot;$&#123;local.server.port&#125;&quot;) 等价注解@LocalServerPort// 3. 环境变量@AutowiredEnvironment environment;this.environment.getProperty(&quot;server.port&quot;) MockMvc期间也是测试了 MockMvc 的使用，需要 @AutoConfigureMockMvc 注解在测试类上，启用相关配置。 12345678910111213141516171819@SpringBootTest@AutoConfigureMockMvcclass WebTest &#123; @Autowired MockMvc mockMvc; void testMockMvc() &#123; String expected = &quot;预期的 json 字符串&quot;; mockMvc.perform( MockMvcRequestBuilders .get(&quot;路由&quot;) ) .andExpect(MockMvcResultMatchers.status().isOk()) .andExpect(MockMvcResultMatchers.content().json(expected)) .andDo(MockMvcResultHandlers.print()); &#125;&#125; 使用异常但使用过程并不顺利，遇到了以下异常： 12345678org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NullPointerException at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) at javax.servlet.http.HttpServlet.service(HttpServlet.java:626) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:72) at javax.servlet.http.HttpServlet.service(HttpServlet.java:733) 通过异常信息，只能获取到空指针异常，无法直接定位到触发原因，但实际上是由于测试时，没有添加请求参数引起的，因此在遇到类似的异常时，需要注意请求本身是否存在违规的操作，缺失 header、参数等信息。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"Unit Test","slug":"Spring-Boot/Unit-Test","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/Unit-Test/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"http://daiwenzh5.github.io/tags/Unit-Test/"},{"name":"MVC","slug":"MVC","permalink":"http://daiwenzh5.github.io/tags/MVC/"},{"name":"Mock","slug":"Mock","permalink":"http://daiwenzh5.github.io/tags/Mock/"}]},{"title":"async setup() 引发异常","slug":"yuque/async setup() 引发异常","date":"2021-12-08T20:19:25.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/12/09/yuque/async setup() 引发异常/","link":"","permalink":"http://daiwenzh5.github.io/2021/12/09/yuque/async%20setup()%20%E5%BC%95%E5%8F%91%E5%BC%82%E5%B8%B8/","excerpt":"问题描述在 uniapp 项目中使用 vue3 开发，在 setup script 标签中使用顶层 await 语句，导致页面空白，而控制台打印异常。","text":"问题描述在 uniapp 项目中使用 vue3 开发，在 setup script 标签中使用顶层 await 语句，导致页面空白，而控制台打印异常。 项目环境12编译器: HBX 3.3 Betavue: 3.2.23 异常原因这是因为 顶层 await 必须配合 async setup() 必须与 Suspense 组合使用，而当前版本的 uniapp 并不支持该组件。 解决方案在 setup script 中使用 nextTick 方法，在回调中使用 await 语句，而非在顶层使用。 1234567891011&lt;script setup&gt;import &#123; ref, nextTick &#125; from &quot;vue&quot;;&#x2F;&#x2F; 定义任意响应对象const anything &#x3D; ref(&quot;hello&quot;);nextTick(async () &#x3D;&gt; &#123; &#x2F;&#x2F; 执行异步方法 const res &#x3D; await asyncFunction(); &#x2F;&#x2F; 将返回结果，回写到响应对象的值中 anything.value &#x3D; res;&#125;);&lt;&#x2F;script&gt;","categories":[{"name":"Vue3","slug":"Vue3","permalink":"http://daiwenzh5.github.io/categories/Vue3/"},{"name":"异常","slug":"Vue3/异常","permalink":"http://daiwenzh5.github.io/categories/Vue3/%E5%BC%82%E5%B8%B8/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://daiwenzh5.github.io/tags/Vue3/"},{"name":"Uniapp","slug":"Uniapp","permalink":"http://daiwenzh5.github.io/tags/Uniapp/"},{"name":"async setup","slug":"async-setup","permalink":"http://daiwenzh5.github.io/tags/async-setup/"},{"name":"异常","slug":"异常","permalink":"http://daiwenzh5.github.io/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"重复参数校验","slug":"yuque/重复参数校验","date":"2021-11-22T13:14:34.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/11/22/yuque/重复参数校验/","link":"","permalink":"http://daiwenzh5.github.io/2021/11/22/yuque/%E9%87%8D%E5%A4%8D%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/","excerpt":"需求描述需要对列表数据中某个字段验重。","text":"需求描述需要对列表数据中某个字段验重。 解决方案通过自定义注解，借助 spring 参数校验框架，抽象通用逻辑，通过反射获取字段值进行比较。 注解 - NoRepeat12345678910111213141516171819202122232425262728293031323334353637/** * 非重复校验 * * @author daiwenzh5 * @date 2021/11/22 */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)@Repeatable(NotRepeat.List.class)@Constraint(validatedBy = NotRepeatConstraintValidator.class)public @interface NotRepeat &#123; /** * 字段名称 */ String field(); /** * 增强校验方法注册的 bean 名称 &lt;br&gt; * 可以将数据库查重注册为 bean */ String beanName() default &quot;&quot;; String message() default &quot;&#123;javax.validation.constraints.NotRepeat.message&#125;&quot;; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; @Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;) @Retention(RUNTIME) @Documented @interface List &#123; NotRepeat[] value(); &#125;&#125; 校验逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 非重复字段校验 * * @author daiwenzh5 * @date 2021/11/22 */public class NotRepeatConstraintValidator implements ConstraintValidator&lt;NotRepeat, List&lt;?&gt;&gt; &#123; private String field; private String message; @SuppressWarnings(&#123;&quot;java:S3740&quot;, &quot;rawtypes&quot;&#125;) private IRepeatValidator bean; @Override public void initialize(NotRepeat constraintAnnotation) &#123; field = constraintAnnotation.field(); message = constraintAnnotation.message(); if (CharSequenceUtil.isNotEmpty(constraintAnnotation.beanName())) &#123; bean = SpringUtil.getBean(constraintAnnotation.beanName()); &#125; &#125; @Override public boolean isValid(List&lt;?&gt; value, ConstraintValidatorContext context) &#123; Consumer&lt;String&gt; setMessage = param -&gt; &#123; context.disableDefaultConstraintViolation(); context.buildConstraintViolationWithTemplate(String.format( message, param )) .addConstraintViolation(); &#125;; var first = findInList(value); if (first.isPresent()) &#123; setMessage.accept(String.format( message, first.get() )); return false; &#125; if (bean != null) &#123; first = findInBean(value); if (first.isPresent()) &#123; setMessage.accept(first.get()); return false; &#125; &#125; return true; &#125; /** * 从 bean 方法中查找重复项 */ @NotNull private Optional&lt;String&gt; findInBean(List&lt;?&gt; value) &#123; Optional&lt;String&gt; first; //noinspection unchecked first = bean.pick(value) .stream() .map(Object::toString) .sorted() .findFirst(); return first; &#125; /** * 从参数中查找 */ @NotNull private Optional&lt;String&gt; findInList(List&lt;?&gt; value) &#123; return value.stream() // 获取字段值 .map(this::getValue) // 去除 null 值 .filter(Objects::nonNull) // 按值分组，并统计数量 .collect(Collectors.groupingBy( Function.identity(), Collectors.counting() )).entrySet() .stream() // 筛选数量大于 1 .filter(it -&gt; it.getValue() &gt; 1) // 取第一个数 .findFirst() .map(Map.Entry::getKey) .map(Object::toString); &#125; private Object getValue(Object object) &#123; return ReflectUtil.getFieldValue(object, field); &#125;&#125; 增强校验方法简单的建造工厂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * 基于 mybatis plus 的重复校验简单工厂 * * @author daiwenzh5 * @date 2021/11/23 */@UtilityClasspublic class RepeatValidatorMybatisPlusFactory &#123; /** * 创建一个基于 mybatis plus 的&#123;@linkplain IRepeatValidator 重复校验器&#125; * * @param baseMapper 基于 mybatis plus mapper 类 * @param field 字段名 * @param getter 字段的 getter 方法 * @param &lt;T&gt; 待校验数据的实体类型 * @param &lt;R&gt; mapper 映射的实体类型 * @return &#123;@linkplain IRepeatValidator 重复校验器&#125; */ public &lt;T, R&gt; IRepeatValidator&lt;T&gt; create( BaseMapper&lt;R&gt; baseMapper, String field, Function&lt;T, String&gt; getter ) &#123; return create(baseMapper, field, getter, (list, rQueryWrapper) -&gt; rQueryWrapper); &#125; /** * 创建一个基于 mybatis plus 的&#123;@linkplain IRepeatValidator 重复校验器&#125; * * @param baseMapper 基于 mybatis plus mapper 类 * @param field 字段名 * @param getter 字段的 getter 方法 * @param moreWrapper 更多查询条件 * @param &lt;T&gt; 待校验数据的实体类型 * @param &lt;R&gt; mapper 映射的实体类型 * @return &#123;@linkplain IRepeatValidator 重复校验器&#125; */ public &lt;T, R&gt; IRepeatValidator&lt;T&gt; create( BaseMapper&lt;R&gt; baseMapper, String field, Function&lt;T, String&gt; getter, BiFunction&lt;List&lt;T&gt;, QueryWrapper&lt;R&gt;, QueryWrapper&lt;R&gt;&gt; moreWrapper) &#123; return list -&gt; &#123; val collect = list.stream() .map(getter) .collect(Collectors.toList()); return baseMapper.selectObjs( moreWrapper.apply(list, new QueryWrapper&lt;R&gt;() .select(field) .in(field, collect)) ); &#125;; &#125; /** * 创建一个基于 mybatis plus 的&#123;@linkplain IRepeatValidator 重复校验器&#125; &lt;br&gt; * 防止更新时和自身发生验重 * * @param baseMapper 基于 mybatis plus mapper 类 * @param field 字段名 * @param getter 字段的 getter 方法 * @param id 主键名 * @param idGetter 主键的 getter 方法 * @param &lt;T&gt; 待校验数据的实体类型 * @param &lt;R&gt; mapper 映射的实体类型 * @return &#123;@linkplain IRepeatValidator 重复校验器&#125; */ public &lt;T, R&gt; IRepeatValidator&lt;T&gt; create( BaseMapper&lt;R&gt; baseMapper, String field, Function&lt;T, String&gt; getter, String id, Function&lt;T, Object&gt; idGetter ) &#123; return create(baseMapper, field, getter, id, idGetter, (list, rQueryWrapper) -&gt; rQueryWrapper); &#125; /** * 创建一个基于 mybatis plus 的&#123;@linkplain IRepeatValidator 重复校验器&#125; &lt;br&gt; * 防止更新时和自身发生验重 * * @param baseMapper 基于 mybatis plus mapper 类 * @param field 字段名 * @param getter 字段的 getter 方法 * @param id 主键名 * @param idGetter 主键的 getter 方法 * @param moreWrapper 更多查询条件 * @param &lt;T&gt; 待校验数据的实体类型 * @param &lt;R&gt; mapper 映射的实体类型 * @return &#123;@linkplain IRepeatValidator 重复校验器&#125; */ public &lt;T, R&gt; IRepeatValidator&lt;T&gt; create( BaseMapper&lt;R&gt; baseMapper, String field, Function&lt;T, String&gt; getter, String id, Function&lt;T, Object&gt; idGetter, BiFunction&lt;List&lt;T&gt;, QueryWrapper&lt;R&gt;, QueryWrapper&lt;R&gt;&gt; moreWrapper ) &#123; return create(baseMapper, field, getter, (list, rQueryWrapper) -&gt; &#123; val ids = list.stream().map(idGetter).collect(Collectors.toList()); return moreWrapper.apply(list, rQueryWrapper.notIn( !ids.isEmpty(), id, ids )); &#125;); &#125;&#125; 注册方法12345678@Beanpublic IRepeatValidator&lt;T&gt; checkSomeField() &#123; return RepeatValidatorMybatisPlusFactory.create( mapper, &quot;字段&quot;, T::getField ));&#125; 注意事项对于更新时的校验，为了防止字段值未修改，但因为在库中查询已存在，导致异常的情况，应该将 id 作为查询条件，筛选出所有不在 id 列表中的数据。 12345678910@Beanpublic IRepeatValidator&lt;T&gt; checkSomeField() &#123; return RepeatValidatorMybatisPlusFactory.create( mapper, &quot;字段&quot;, T::getField, &quot;主键&quot;, T::getId ));&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://daiwenzh5.github.io/categories/Spring/"},{"name":"参数校验","slug":"Spring/参数校验","permalink":"http://daiwenzh5.github.io/categories/Spring/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://daiwenzh5.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring","slug":"Spring","permalink":"http://daiwenzh5.github.io/tags/Spring/"},{"name":"参数校验","slug":"参数校验","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"name":"自定义","slug":"自定义","permalink":"http://daiwenzh5.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"}]},{"title":"Spring Cloud Config","slug":"yuque/Spring Cloud Config","date":"2021-11-16T02:27:46.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/11/16/yuque/Spring Cloud Config/","link":"","permalink":"http://daiwenzh5.github.io/2021/11/16/yuque/Spring%20Cloud%20Config/","excerpt":"运行环境123&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;&lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt;","text":"运行环境123&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;spring-boot.version&gt;2.3.7.RELEASE&lt;/spring-boot.version&gt;&lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; 常用 API查看配置12const url = `&#123;&#123;ip&#125;&#125;:&#123;&#123;port&#125;&#125;/&#123;&#123;applitionName&#125;&#125;-&#123;&#123;env&#125;&#125;.yml`;# 如 http://localhost:10001/client-dev.yml 本地模式12345678910spring: application: name: config-server profiles: active: native # 本地配置的固定启动环境 cloud: config: server: native: search-locations: file:///本机地址，支持 classpath 环境异常当没有指定 spring.profiles.active=native 时，以读取 Git 仓库为配置，出现以下异常： 1234567891011***************************APPLICATION FAILED TO START***************************Description:Invalid config server configuration.Action:If you are using the git profile, you need to set a Git URI in your configuration. If you are using a native profile and have spring.cloud.config.server.bootstrap&#x3D;true, you need to use a composite configuration. 注意：谨防在全局配置了环境变量，由于在系统环境变量中设置了公司常用的环境名，导致配置文件中的激活项被覆盖，而一直无法启动。 Git 模式123456spring: cloud: config: server: git: uri: file:///本机地址 本地仓库支持设置 uri 为本地路径，但需要该仓库存在，并且访问的配置（如：client-dev.yml）已被 git 托管。 远程仓库12345678spring: cloud: config: server: git: uri: 仓库地址 username: 用户名 password: 密码 加密密码由于在项目中使用明文配置密码，不太合适，较好的方式使用对其进行加密。 123456&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;!-- 版本号，以 maven 仓库中的配适为准 --&gt; &lt;version&gt;3.0.4&lt;/version&gt;&lt;/dependency&gt; 123jasypt: encryptor: password: 加密密码 使用方式： 1234567891011@Testvoid encrypt() &#123; Assertions.assertDoesNotThrow(() -&gt; &#123; final String encrypt = stringEncryptor.encrypt(&quot;123456&quot;); System.out.println(encrypt); Assertions.assertEquals( &quot;123456&quot;, stringEncryptor.decrypt(encrypt) ); &#125;);&#125; 在程序中打印出加密后的字符串，并在配置文件中使用 ENC() 包裹，标识其为一串加密字符。 123### 仅展示密码部分git: password: ENC(加密字符) 安全认证到目前为止，配置中心的所有 api 都是可随意访问的，若需要对公网暴露，则需要添加登录鉴权更安全些。添加 security 依赖，并简单配置： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 12345spring: security: user: name: config-server password: password123 注册中心1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 1234eureka: client: service-url: defaultZone: http://ip:port/eureka/ 并在启动类上添加 @EnableEurekaClient 注解。","categories":[{"name":"微服务","slug":"微服务","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud","slug":"微服务/Spring-Cloud","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://daiwenzh5.github.io/tags/Spring-Cloud/"},{"name":"Config","slug":"Config","permalink":"http://daiwenzh5.github.io/tags/Config/"},{"name":"微服务","slug":"微服务","permalink":"http://daiwenzh5.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"配置中心","slug":"配置中心","permalink":"http://daiwenzh5.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"}]},{"title":"WebFilter 路径匹配模式不生效","slug":"yuque/WebFilter 路径匹配模式不生效","date":"2021-11-10T11:23:17.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/11/10/yuque/WebFilter 路径匹配模式不生效/","link":"","permalink":"http://daiwenzh5.github.io/2021/11/10/yuque/WebFilter%20%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88/","excerpt":"需求描述在登录授权时，需要从 header 中获取 token 进行鉴权，通常使用过滤器处理指定的访问请求，但在使用 @WebFilter 注解时，发现其路径匹配模式不生效，即 url、urlPatterns 属性配置后，拦截了所有请求。","text":"需求描述在登录授权时，需要从 header 中获取 token 进行鉴权，通常使用过滤器处理指定的访问请求，但在使用 @WebFilter 注解时，发现其路径匹配模式不生效，即 url、urlPatterns 属性配置后，拦截了所有请求。 解决方案@WebServlet，@WebFilter，@WebListener 注解，需要和 @ServletComponentScan 注解配套使用，表明其为 servlet 组件，而不是普通的 spring 组件，当使用 @Component 注解后，会优先被注册为 spring 组件，导致 servlet 扫描器失效。 1234567891011121314@ServletComponentScan(&quot;包名&quot;)@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125;// 扫描所有 user 下的路径@WebFilter(&quot;user/*&quot;)public class TestFilter implements Filter&#123;&#125; 补充可以通过 FilterRegistrationBean 装饰器，以编程方式手动注册过滤器。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"WebFilter","slug":"Spring-Boot/WebFilter","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/WebFilter/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"WebFilter","slug":"WebFilter","permalink":"http://daiwenzh5.github.io/tags/WebFilter/"},{"name":"属性失效","slug":"属性失效","permalink":"http://daiwenzh5.github.io/tags/%E5%B1%9E%E6%80%A7%E5%A4%B1%E6%95%88/"},{"name":"urlPatterns","slug":"urlPatterns","permalink":"http://daiwenzh5.github.io/tags/urlPatterns/"}]},{"title":"Bootstrap 多环境配置","slug":"yuque/Bootstrap 多环境配置","date":"2021-11-06T03:50:40.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/11/06/yuque/Bootstrap 多环境配置/","link":"","permalink":"http://daiwenzh5.github.io/2021/11/06/yuque/Bootstrap%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"需求描述由于在 bootstrap.yml 文件中配置 CI/CD 的环境变量，而本地开发时并没有相关环境，所以需要手动切换其属性，在提交代码时，需要关注该配置文件是否会与云端冲突，极其浪费精力。因此需要能够屏蔽本地与云端配置差异的手段。","text":"需求描述由于在 bootstrap.yml 文件中配置 CI/CD 的环境变量，而本地开发时并没有相关环境，所以需要手动切换其属性，在提交代码时，需要关注该配置文件是否会与云端冲突，极其浪费精力。因此需要能够屏蔽本地与云端配置差异的手段。 解决方案由于在测试过程中，发现使用 bootstrap-local.yml 的方式，无法成功切换环境，因此使用 spring 的指定外部配置文件的方式。通过在项目启动时，添加程序启动参数，手动指定配置文件所在路径 --spring.config.location=classpath:/local/。注意：local 是在 resources 下建立的目录，需要以 / 结尾表示其为目录。当然，此处亦可精确指定加载哪个配置文件，但每个（放置在 resources 目录下的文件）都需要 classpath:/ 开头，以表示其在类加载目录下，多个文件之间以 , 分割。​","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"配置文件","slug":"Spring-Boot/配置文件","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"配置文件","slug":"配置文件","permalink":"http://daiwenzh5.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"多环境","slug":"多环境","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%8E%AF%E5%A2%83/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://daiwenzh5.github.io/tags/Bootstrap/"}]},{"title":"同时处理 XML 和 JSON 接口","slug":"yuque/同时处理 XML 和 JSON 接口","date":"2021-10-31T07:22:11.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/10/31/yuque/同时处理 XML 和 JSON 接口/","link":"","permalink":"http://daiwenzh5.github.io/2021/10/31/yuque/%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%20XML%20%E5%92%8C%20JSON%20%E6%8E%A5%E5%8F%A3/","excerpt":"需求描述出入参同时支持 XML 和 JSON 格式。","text":"需求描述出入参同时支持 XML 和 JSON 格式。 解决方案在接口请求映射器注解中，指定 consumes 的媒体类型，用于标记入参格式，指定 produces 的媒体类型，用于标记出参格式。 123456789@RequestMapping(value = &quot;地址&quot;, consumes = &#123; MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE &#125;, produces = &#123; MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE &#125;) 同时，需要在 pom 中添加 xml 处理依赖。 12345&lt;!-- 一般的由默认的 spring jackson 依赖控制版本号 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.jaxrs&lt;/groupId&gt; &lt;artifactId&gt;jackson-jaxrs-xml-provider&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"参数处理","slug":"Spring-Boot/参数处理","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"参数处理","slug":"参数处理","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/"},{"name":"XML","slug":"XML","permalink":"http://daiwenzh5.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://daiwenzh5.github.io/tags/JSON/"}]},{"title":"字段类型不一致的问题分析","slug":"yuque/字段类型不一致的问题分析","date":"2021-06-11T02:14:30.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/06/11/yuque/字段类型不一致的问题分析/","link":"","permalink":"http://daiwenzh5.github.io/2021/06/11/yuque/%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/","excerpt":"问题描述使用 mybatis 的结果集自动映射，发生了实体属性类型与表字段类型不一致；但实际上，相关实体的属性与表结构完全匹配。关于实体类，是使用代码生成读取表结构生成的，但使用了公共父类，其中抽取出了一些通用的字段（包括主键、创建时间等）。","text":"问题描述使用 mybatis 的结果集自动映射，发生了实体属性类型与表字段类型不一致；但实际上，相关实体的属性与表结构完全匹配。关于实体类，是使用代码生成读取表结构生成的，但使用了公共父类，其中抽取出了一些通用的字段（包括主键、创建时间等）。 1234567891011121314151617181920212223242526272829303132@Data@Accessors(chain = true)public class BaseEntity&lt;Id extends Serializable&gt; &#123; @TableId protected Id id; @TableField(value = &quot;create_by&quot;, fill = INSERT, updateStrategy = NEVER) protected String createBy; @TableField(value = &quot;create_time&quot;, fill = INSERT, updateStrategy = NEVER) protected Date createTime; @TableField(value = &quot;update_by&quot;, fill = FieldFill.UPDATE) protected String updateBy; @TableField(value = &quot;update_time&quot;, fill = FieldFill.UPDATE) protected Date updateTime; @TableField(&quot;ext1&quot;) protected String ext1; @TableField(&quot;ext2&quot;) protected String ext2; @TableField(&quot;ext3&quot;) protected String ext3; @TableField(&quot;ext4&quot;) protected String ext4;&#125; 不必计较父类中设置主键的合理性。 BaseEntity.java 是基于 mybatis-plus，因此所有字段添加了相应的注解。实体中依赖 lombok 隐藏 getter、setter 的实现细节，并使用了 @Builder 辅助实体创建。 解决方案原因 使用 mybatis plus 的注解式开发，默认启用了 mybatis 的结果集自动映射，会通过构造器创建实体； 使用 lombok @Builder，导致实体生成了不包含父类属性的全参构造器； mybatis 反射获取实体属性，构建属性类型、字段类型以及字段名称的独立列表； mybatis 反射获取到实体构造器，当没有默认构造器时，会根据构造器参数索引顺序匹配字段，由于构造器参数长度是小于字段长度的，导致参数类型不匹配； 解决在代码中添加默认构造器（通过反射获取，与可见性无关）。 建议 不要在表实体中使用 lombok 的 @Builder，@AllArgsConstructor，防止在继承父类时，产生不完全的“全参”构造器； 或者强制在表实体中启用 lombok 的 @NoArgsConstructor，保证一定存在无参构造器； 也可以在表实体目录中强制禁止相关 lombok 注解，防止其他开发无意中使用； 12lombok.allArgsConstructor.flagUsage &#x3D; ERRORlombok.builder.flagUsage &#x3D; ERROR 代码分析DefaultResultSetHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException &#123; final ResultLoaderMap lazyLoader = new ResultLoaderMap(); // 1、创建结果对象 Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix); if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123; final MetaObject metaObject = configuration.newMetaObject(rowValue); boolean foundValues = this.useConstructorMappings; if (shouldApplyAutomaticMappings(resultMap, false)) &#123; foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues; &#125; foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues; foundValues = lazyLoader.size() &gt; 0 || foundValues; rowValue = foundValues || configuration.isReturnInstanceForEmptyRow() ? rowValue : null; &#125; return rowValue;&#125;private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, ResultLoaderMap lazyLoader, String columnPrefix) throws SQLException &#123; this.useConstructorMappings = false; // reset previous mapping result final List&lt;Class&lt;?&gt;&gt; constructorArgTypes = new ArrayList&lt;&gt;(); final List&lt;Object&gt; constructorArgs = new ArrayList&lt;&gt;(); // 2、创建结果对象（使用可能存在的构造参数） Object resultObject = createResultObject(rsw, resultMap, constructorArgTypes, constructorArgs, columnPrefix); if (resultObject != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123; final List&lt;ResultMapping&gt; propertyMappings = resultMap.getPropertyResultMappings(); for (ResultMapping propertyMapping : propertyMappings) &#123; // issue gcode #109 &amp;&amp; issue #149 if (propertyMapping.getNestedQueryId() != null &amp;&amp; propertyMapping.isLazy()) &#123; resultObject = configuration.getProxyFactory().createProxy(resultObject, lazyLoader, configuration, objectFactory, constructorArgTypes, constructorArgs); break; &#125; &#125; &#125; this.useConstructorMappings = resultObject != null &amp;&amp; !constructorArgTypes.isEmpty(); // set current mapping result return resultObject;&#125;private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix) throws SQLException &#123; final Class&lt;?&gt; resultType = resultMap.getType(); final MetaClass metaType = MetaClass.forClass(resultType, reflectorFactory); final List&lt;ResultMapping&gt; constructorMappings = resultMap.getConstructorResultMappings(); if (hasTypeHandlerForResultObject(rsw, resultType)) &#123; return createPrimitiveResultObject(rsw, resultMap, columnPrefix); &#125; else if (!constructorMappings.isEmpty()) &#123; return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix); &#125; else if (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123; // 2.1、使用无参构造器创建对象 return objectFactory.create(resultType); &#125; else if (shouldApplyAutomaticMappings(resultMap, false)) &#123; // 2.2、使用有参的构造器创建对象 return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs); &#125; throw new ExecutorException(&quot;Do not know how to create an instance of &quot; + resultType);&#125;private Object createByConstructorSignature(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs) throws SQLException &#123; final Constructor&lt;?&gt;[] constructors = resultType.getDeclaredConstructors(); // 3、获取构造器 final Constructor&lt;?&gt; defaultConstructor = findDefaultConstructor(constructors); if (defaultConstructor != null) &#123; // 4、使用构造器创建对象 return createUsingConstructor(rsw, resultType, constructorArgTypes, constructorArgs, defaultConstructor); &#125; else &#123; for (Constructor&lt;?&gt; constructor : constructors) &#123; if (allowedConstructorUsingTypeHandlers(constructor, rsw.getJdbcTypes())) &#123; return createUsingConstructor(rsw, resultType, constructorArgTypes, constructorArgs, constructor); &#125; &#125; &#125; throw new ExecutorException(&quot;No constructor found in &quot; + resultType.getName() + &quot; matching &quot; + rsw.getClassNames());&#125;private Constructor&lt;?&gt; findDefaultConstructor(final Constructor&lt;?&gt;[] constructors) &#123; // 3.1、仅包含一个构造器直接返回 if (constructors.length == 1) &#123; return constructors[0]; &#125; // 3.2、返回包含 @AutomapConstructor 的构造器 for (final Constructor&lt;?&gt; constructor : constructors) &#123; if (constructor.isAnnotationPresent(AutomapConstructor.class)) &#123; return constructor; &#125; &#125; return null;&#125;private Object createUsingConstructor(ResultSetWrapper rsw, Class&lt;?&gt; resultType, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, Constructor&lt;?&gt; constructor) throws SQLException &#123; boolean foundValues = false; for (int i = 0; i &lt; constructor.getParameterTypes().length; i++) &#123; // 4.1、通过构造器参数进行匹配参数类型 Class&lt;?&gt; parameterType = constructor.getParameterTypes()[i]; String columnName = rsw.getColumnNames().get(i); TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(parameterType, columnName); Object value = typeHandler.getResult(rsw.getResultSet(), columnName); constructorArgTypes.add(parameterType); constructorArgs.add(value); foundValues = value != null || foundValues; &#125; return foundValues ? objectFactory.create(resultType, constructorArgTypes, constructorArgs) : null;&#125;","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/categories/Mybatis/"},{"name":"结果集","slug":"Mybatis/结果集","permalink":"http://daiwenzh5.github.io/categories/Mybatis/%E7%BB%93%E6%9E%9C%E9%9B%86/"}],"tags":[{"name":"结果集","slug":"结果集","permalink":"http://daiwenzh5.github.io/tags/%E7%BB%93%E6%9E%9C%E9%9B%86/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/tags/Mybatis/"},{"name":"Lombok","slug":"Lombok","permalink":"http://daiwenzh5.github.io/tags/Lombok/"},{"name":"异常分析","slug":"异常分析","permalink":"http://daiwenzh5.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"}]},{"title":"JetCache 使用","slug":"yuque/JetCache 使用","date":"2021-04-23T06:01:54.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/04/23/yuque/JetCache 使用/","link":"","permalink":"http://daiwenzh5.github.io/2021/04/23/yuque/JetCache%20%E4%BD%BF%E7%94%A8/","excerpt":"需求描述解决方案","text":"需求描述解决方案Optional 支持由于 Optional 并不支持序列化，因此无法直接将其作为方法返回值、托管给 JetCache。必须对其进行拓展，添加自定义的编码器以及解码器。 环境依赖于 com.alicp.jetcache:jetcache-core:2.5.16。 配置只要将自定义的编码器注册为 bean 即可。 1234jetcache: remote: default: valueEncoder: bean:jetValueEncoder 编码器实现 在序列化之前，将 Optional 中的值取出，并在打上自定义的标记（IDENTITY_NUMBER 的值），对于非 Optional 类型的数据，则沿用默认的编码器器（JavaValueEncoder）； 编码器需要注册成 spring bean，启用自定义标记之后，解码器则通过读取自定义标记进行匹配； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@Componentpublic class JetValueEncoder extends JavaValueEncoder &#123; private static final int INIT_BUF_SIZE = 256; private static final ThreadLocal&lt;WeakReference&lt;ByteArrayOutputStream&gt;&gt; THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; new WeakReference&lt;&gt;(new ByteArrayOutputStream(INIT_BUF_SIZE))); protected static int IDENTITY_NUMBER = 0x4A953A84; public JetValueEncoder() &#123; this(true); &#125; public JetValueEncoder(boolean useIdentityNumber) &#123; super(useIdentityNumber); registerDecoder(); &#125; // 注册解码器，此处为匿名内部类，直接实例并注册到 DecoderMap， // 键值为JetValueEncoder.IDENTITY_NUMBER，自定义标记 // 实现逻辑，在反序列化之后，将标记匹配的值封装到 Optional 中 // 标记不匹配的，则被其他解码器处理，不用考虑 protected void registerDecoder() &#123; SpringJavaValueDecoder decoder = new SpringJavaValueDecoder(true) &#123; @Override @SuppressWarnings(&quot;unchecked&quot;) public Object doApply(byte[] buffer) throws Exception &#123; Object obj = super.doApply(buffer); if (obj instanceof CacheValueHolder) &#123; CacheValueHolder&lt;Object&gt; valueHolder = (CacheValueHolder&lt;Object&gt;) obj; valueHolder.setValue(Optional.ofNullable(valueHolder.getValue())); &#125; return obj; &#125; &#125;; DecoderMap.register(JetValueEncoder.IDENTITY_NUMBER, decoder); &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public byte[] apply(Object value) &#123; if (value instanceof CacheValueHolder) &#123; CacheValueHolder&lt;Object&gt; valueHolder = (CacheValueHolder&lt;Object&gt;) value; Object holderValue = ((CacheValueHolder&lt;?&gt;) value).getValue(); if (holderValue instanceof Optional) &#123; Optional&lt;?&gt; valeOpt = (Optional&lt;?&gt;) holderValue; valeOpt.ifPresent(valueHolder::setValue); return doApply(value); &#125; &#125; return super.apply(value); &#125; /** * 从父类中拷贝，由于父类中 IDENTITY_NUMBER 是静态变量，&lt;br/&gt; * 且没有提供可重构 getter，所以不得不进行代码搬运法。╮(╯▽╰)╭&lt;br/&gt; * 父类中应该使用 getIdentityNumber() 方法获取 IDENTITY_NUMBER 的值，&lt;br/&gt; * * @see JavaValueEncoder#apply(Object) */ private byte[] doApply(Object value) &#123; try &#123; WeakReference&lt;ByteArrayOutputStream&gt; ref = THREAD_LOCAL.get(); ByteArrayOutputStream bos = ref.get(); if (bos == null) &#123; bos = new ByteArrayOutputStream(INIT_BUF_SIZE); THREAD_LOCAL.set(new WeakReference&lt;&gt;(bos)); &#125; try &#123; if (useIdentityNumber) &#123; bos.write((IDENTITY_NUMBER &gt;&gt; 24) &amp; 0xFF); bos.write((IDENTITY_NUMBER &gt;&gt; 16) &amp; 0xFF); bos.write((IDENTITY_NUMBER &gt;&gt; 8) &amp; 0xFF); bos.write(IDENTITY_NUMBER &amp; 0xFF); &#125; ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(value); oos.flush(); return bos.toByteArray(); &#125; finally &#123; bos.reset(); &#125; &#125; catch (IOException e) &#123; throw new CacheEncodeException(&quot;Java Encode error. &quot; + &quot;msg=&quot; + e.getMessage(), e); &#125; &#125;&#125; 分析从源码中 SpringConfigProvider#parseValueEncoder 可以找到编码器的加载入口，当 valueEncoder 属性匹配到 “bean:”前缀的编码器时，则启用该 bean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1、ExternalCacheAutoInit#parseGeneralConfig // 自动初始化配置 protected void parseGeneralConfig(CacheBuilder builder, ConfigTree ct) &#123; super.parseGeneralConfig(builder, ct); ExternalCacheBuilder ecb = (ExternalCacheBuilder) builder; ecb.setKeyPrefix(ct.getProperty(&quot;keyPrefix&quot;)); // 设置编码器，指定了配置中的 key：valueEncoder ecb.setValueEncoder(configProvider.parseValueEncoder(ct.getProperty(&quot;valueEncoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY))); ecb.setValueDecoder(configProvider.parseValueDecoder(ct.getProperty(&quot;valueDecoder&quot;, CacheConsts.DEFAULT_SERIAL_POLICY))); &#125;// 2、SpringConfigProvider#parseValueEncoder // spring 环境中的配置规则，先尝试搜索是否存在注册为 spring bean 的编码器 public Function&lt;Object, byte[]&gt; parseValueEncoder(String valueEncoder) &#123; // 进入 bean 加载方法 String beanName = parseBeanName(valueEncoder); // bean 名称存在时注册 spring 托管的编码器 if (beanName == null) &#123; return super.parseValueEncoder(valueEncoder); &#125; else &#123; Object bean = applicationContext.getBean(beanName); if (bean instanceof Function) &#123; return (Function&lt;Object, byte[]&gt;) bean; &#125; else &#123; return ((SerialPolicy) bean).encoder(); &#125; &#125; &#125;// 3、SpringConfigProvider#parseBeanName// bean 名称的解析，需要在配置文件中指定 valueEncode 属性：&#x27;bean:anyName&#x27;private String parseBeanName(String str) &#123; // 通过 “bean:” 前缀匹配 bean 名称 final String beanPrefix = &quot;bean:&quot;; int len = beanPrefix.length(); if (str != null &amp;&amp; str.startsWith(beanPrefix) &amp;&amp; str.length() &gt; len) &#123; return str.substring(len); &#125; else &#123; return null; &#125; &#125;// 4、AbstractValueDecoder#apply // 解码器入口，对于 useIdentityNumber = true，及开启自定义标记的序列化数据， // 需要在 DecoderMap 中通过 identityNumber 进行匹配public Object apply(byte[] buffer) &#123; try &#123; if (useIdentityNumber) &#123; DecoderMap.registerBuildInDecoder(); int identityNumber = parseHeader(buffer); AbstractValueDecoder decoder = DecoderMap.getDecoder(identityNumber); Objects.requireNonNull(decoder, &quot;no decoder for identity number:&quot; + identityNumber); return decoder.doApply(buffer); &#125; else &#123; return doApply(buffer); &#125; &#125; catch (Exception e) &#123; throw new CacheEncodeException(&quot;decode error&quot;, e); &#125; &#125;","categories":[{"name":"缓存","slug":"缓存","permalink":"http://daiwenzh5.github.io/categories/%E7%BC%93%E5%AD%98/"},{"name":"Redis","slug":"缓存/Redis","permalink":"http://daiwenzh5.github.io/categories/%E7%BC%93%E5%AD%98/Redis/"}],"tags":[{"name":"JetCache","slug":"JetCache","permalink":"http://daiwenzh5.github.io/tags/JetCache/"},{"name":"多级缓存","slug":"多级缓存","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"},{"name":"使用","slug":"使用","permalink":"http://daiwenzh5.github.io/tags/%E4%BD%BF%E7%94%A8/"},{"name":"拓展","slug":"拓展","permalink":"http://daiwenzh5.github.io/tags/%E6%8B%93%E5%B1%95/"}]},{"title":"Feign 自定义配置","slug":"yuque/Feign 自定义配置","date":"2021-03-30T08:02:00.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/03/30/yuque/Feign 自定义配置/","link":"","permalink":"http://daiwenzh5.github.io/2021/03/30/yuque/Feign%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE/","excerpt":"需求描述在微服务项目中，需要请求第三方接口，通常情况下我们使用 spring 的 restTemplate。但接触到 feign 之后，这种将远程方法伪装成本地接口，屏蔽请求感知的方式，无疑更优雅。但对于 oauth 认证，需要配置请求头，即设置 feign 的自定义配置。","text":"需求描述在微服务项目中，需要请求第三方接口，通常情况下我们使用 spring 的 restTemplate。但接触到 feign 之后，这种将远程方法伪装成本地接口，屏蔽请求感知的方式，无疑更优雅。但对于 oauth 认证，需要配置请求头，即设置 feign 的自定义配置。 自定义授权头信息请求远程连接@FeignClient 用于注册接口为 feign 客户端，在 spring cloud 项目中，需要在其 value（或 name）属性中指定对应的微服务名，url 置空（将自动匹配配置中西地址）。当需要调用任意的 http 请求时，只要给定 url 值即可。注意 ：此时，虽然不是请求微服务接口，仍然需要设置 name，填写任意（不冲突的）名称即可。 授权流程授权配置需要通过自定义配置属性来指定请求头，对应 @FeignClient 的 configuration 属性。该属性指定一个自定义配置类，用于设置 feign 的任意配置。 Basic 认证12345678910111213// @Configuration 托管给 spring 之后，会被注册为全局配置// 局部配置需要指定在 @FeignClient(configuration = SomeAuthConfig.class)public class SomeAuthConfig &#123; @Bean public BasicAuthRequestInterceptor basicAuthRequestInterceptor(SomeProperties someProperties) &#123; // someProperties 是一个属性类 return new BasicAuthRequestInterceptor( someProperties.getAuth().getUser(), someProperties.getAuth().getPassword() ); &#125;&#125; 请求 token123456789101112131415@FeignClient( name = &quot;some-auth&quot;, url = &quot;$&#123;some.auth.url&#125;&quot;, configuration = SomeAuthConfig.class)public interface SomeAuthIntegration &#123; /** * 获取 token * * @return 授权信息 */ @PostMapping(value = &quot;/xxx&quot;) SomeAuthResponse getToken();&#125; 设置 Authorization Header12345678910111213141516171819202122public class SomeTokenConfig &#123; /** * 配置 header auth * * @param authIntegration 授权接口 * @return 请求拦截器 */ @Bean public RequestInterceptor requestInterceptor(SomeAuthIntegration authIntegration) &#123; // 此处使用的是 lambda 表达式返回一个实现 RequestInterceptor 的匿名类， // 在 lambda 表达式外部的操作会在 bean 注册时生效， // 因此，每次获取 token 的操作，应该放在表达式内部 return requestTemplate -&gt; &#123; SomeAuthResponse authResponse = authIntegration.getToken(); requestTemplate.header( AUTHORIZATION, StrUtil.format(&quot;&#123;&#125; &#123;&#125;&quot;, authResponse.getTokenType(), authResponse.getAccessToken()) ); &#125;; &#125;&#125; 已授权请求123456789101112131415@FeignClient( name = &quot;some-reply&quot;, url = &quot;$&#123;some.reply.url&#125;&quot;, configuration = SomeTokenConfig.class)public interface SomeReplyIntegration &#123; /** * 回传状态 * * @param status 状态信息 */ @PostMapping(&quot;/xxx&quot;) void apply(SomeStatus status);&#125; 自定义解码器当响应信息实际返回的是 json 格式，但头信息描述类型是 Content-Type: text/xml;charset=utf-8 （或其他非 *application/json *类型）时，feign 的默认消息转换器无法解析，此时就需要重新使用自定义解码器。在配置类中注册 Decoder bean。 12345678910@Beanpublic Decoder someResponseDecoder() &#123; return new SpringDecoder(() -&gt; new HttpMessageConverters( new MappingJackson2HttpMessageConverter() &#123; &#123; setSupportedMediaTypes(Lists.newArrayList(MediaType.TEXT_XML)); &#125; &#125; ));&#125; 其他feing 基于 http 请求，在其配置类中，可以实现任意 http 的相关配置，包括超时时间、重试次数等。一般情况下，accessToken 存在过期时间，为了防止频繁请求授权，应该在过期之前进行缓存。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://daiwenzh5.github.io/categories/Spring/"},{"name":"Feign","slug":"Spring/Feign","permalink":"http://daiwenzh5.github.io/categories/Spring/Feign/"}],"tags":[{"name":"Feign","slug":"Feign","permalink":"http://daiwenzh5.github.io/tags/Feign/"},{"name":"Configuration","slug":"Configuration","permalink":"http://daiwenzh5.github.io/tags/Configuration/"},{"name":"HTTP","slug":"HTTP","permalink":"http://daiwenzh5.github.io/tags/HTTP/"},{"name":"拦截器","slug":"拦截器","permalink":"http://daiwenzh5.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"实现 Jar 多版本共存","slug":"yuque/实现 Jar 多版本共存","date":"2021-03-22T15:04:51.000Z","updated":"2022-03-03T15:43:10.548Z","comments":true,"path":"2021/03/22/yuque/实现 Jar 多版本共存/","link":"","permalink":"http://daiwenzh5.github.io/2021/03/22/yuque/%E5%AE%9E%E7%8E%B0%20Jar%20%E5%A4%9A%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98/","excerpt":"需求描述现需要实现同时共存两个版本的 SDK，其中存在限定名完全相同的类，但两个类的方法并不完全相同，导致 JVM 在加载时无法按预期的调用类方法。","text":"需求描述现需要实现同时共存两个版本的 SDK，其中存在限定名完全相同的类，但两个类的方法并不完全相同，导致 JVM 在加载时无法按预期的调用类方法。 解决方案由于 SDK 中依赖了大量的封装对象，无法使用简单的反射调用方法，因此自定义类加载器并不能解决。首先想到的是使用 maven 插件，在编译时修改指定的 SDK 的类名，maven-shade-plugin 并不能很好的解决，按照博客中的经验，可以将待处理的模块在一个空白模块中引入，并使用 shade 进行重命名，但是实际类引用的时候，依旧是原类名，只有在 maven 打包后，新名称将被替换值 class 文件中，这就导致了，如果有多个模块进行了调用 SDK，则需要处理多个模块，而且经常出现预期之外的问题，耗费精力。最终是使用 jarjar 来解决的。下载地址 1java -jar jarjar.jar process rule.txt old.jar new.jar 其中，rule.txt 是任意文件名，其中指定了替换规则： 1rule com.old.package.** com.new.package.@1 或者使用 jarjar-maven-plugin（未验证）","categories":[{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"工具/Java","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/Java/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"Java","permalink":"http://daiwenzh5.github.io/tags/Java/"},{"name":"Jar 冲突","slug":"Jar-冲突","permalink":"http://daiwenzh5.github.io/tags/Jar-%E5%86%B2%E7%AA%81/"},{"name":"多版本","slug":"多版本","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"}]},{"title":"打包外部依赖","slug":"yuque/打包外部依赖","date":"2021-03-21T09:30:02.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2021/03/21/yuque/打包外部依赖/","link":"","permalink":"http://daiwenzh5.github.io/2021/03/21/yuque/%E6%89%93%E5%8C%85%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96/","excerpt":"需求描述由于公司 SDK 没有正式上线，只能提供 jar，需要手动添加依赖，在使用 maven 打包的时候提示找不到符号。","text":"需求描述由于公司 SDK 没有正式上线，只能提供 jar，需要手动添加依赖，在使用 maven 打包的时候提示找不到符号。 解决方案将外部 jar 使用 maven 管理 12345678910111213141516171819202122&lt;dependency&gt; &lt;!-- 因为实际不会从远程仓库下载，因此坐标可以填写任意值 --&gt; &lt;groupId&gt;任意值&lt;/groupId&gt; &lt;artifactId&gt;任意值&lt;/artifactId&gt; &lt;version&gt;任意值&lt;/version&gt; &lt;!-- scope 必须是 system，表明是从本地读取信息 --&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;项目中的相对路径&lt;/systemPath&gt;&lt;/dependency&gt;&lt;!-- 额外配置， 默认情况下，外部依赖只会在编译时加载，打包后会丢失， 需要增加以下配置--&gt;&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- includeSystemScope 开启即可--&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt;","categories":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/categories/Maven/"},{"name":"打包","slug":"Maven/打包","permalink":"http://daiwenzh5.github.io/categories/Maven/%E6%89%93%E5%8C%85/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/tags/Maven/"},{"name":"Lib","slug":"Lib","permalink":"http://daiwenzh5.github.io/tags/Lib/"},{"name":"Install","slug":"Install","permalink":"http://daiwenzh5.github.io/tags/Install/"},{"name":"外部依赖","slug":"外部依赖","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96/"}]},{"title":"LocalDate 解析年月字符串","slug":"yuque/LocalDate 解析年月字符串","date":"2021-02-07T09:20:53.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2021/02/07/yuque/LocalDate 解析年月字符串/","link":"","permalink":"http://daiwenzh5.github.io/2021/02/07/yuque/LocalDate%20%E8%A7%A3%E6%9E%90%E5%B9%B4%E6%9C%88%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"需求描述使用 LocalDate 解析 yyyy-MM 格式的字符串时异常：","text":"需求描述使用 LocalDate 解析 yyyy-MM 格式的字符串时异常： 12345Caused by: java.time.DateTimeException: Unable to obtain LocalDate from TemporalAccessor: &#123;Year&#x3D;2021, MonthOfYear&#x3D;1&#125;,ISO of type java.time.format.Parsed at java.time.LocalDate.from(LocalDate.java:368) at java.time.format.Parsed.query(Parsed.java:226) at java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1851) ... 2 more 解决方案字符串解析到 LocalDate 必须具体到日期，因此需要给年月的格式添加默认日期， 1234567891011public static void main(String[] args) &#123; // ① 调整 DateTimeFormatter DateTimeFormatter fmt = new DateTimeFormatterBuilder() .appendPattern(&quot;yyyy-MM&quot;) // 添加默认日期 .parseDefaulting(ChronoField.DAY_OF_MONTH, 1) .toFormatter(); // ② 使用 YearMonth 转换 YearMonth yearMonth = YearMonth.parse(&quot;2021-01&quot;, fmt); LocalDate localDate = yearMonth.atEndOfMonth();&#125;","categories":[{"name":"JDK8","slug":"JDK8","permalink":"http://daiwenzh5.github.io/categories/JDK8/"},{"name":"Time","slug":"JDK8/Time","permalink":"http://daiwenzh5.github.io/categories/JDK8/Time/"}],"tags":[{"name":"JDK8","slug":"JDK8","permalink":"http://daiwenzh5.github.io/tags/JDK8/"},{"name":"Time","slug":"Time","permalink":"http://daiwenzh5.github.io/tags/Time/"},{"name":"LocalDate","slug":"LocalDate","permalink":"http://daiwenzh5.github.io/tags/LocalDate/"},{"name":"日期格式化","slug":"日期格式化","permalink":"http://daiwenzh5.github.io/tags/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"}]},{"title":"发布到私有仓库","slug":"yuque/发布到私有仓库","date":"2021-02-05T17:37:56.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2021/02/06/yuque/发布到私有仓库/","link":"","permalink":"http://daiwenzh5.github.io/2021/02/06/yuque/%E5%8F%91%E5%B8%83%E5%88%B0%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/","excerpt":"需求描述需要将工具类发布到公司的私有仓库中，为了避免每次手动在页面上操作，此处借助 maven 命令行和 idea 启动项实现一键发布。","text":"需求描述需要将工具类发布到公司的私有仓库中，为了避免每次手动在页面上操作，此处借助 maven 命令行和 idea 启动项实现一键发布。 解决方案配置服务器地址12345678&lt;!-- maven settings.xml --&gt;&lt;!-- 未配置时会提示 401 权限不足 --&gt;&lt;server&gt; &lt;id&gt;仓库名&lt;/id&gt; &lt;username&gt;账号&lt;/username&gt; &lt;password&gt;密码&lt;/password&gt;&lt;/server&gt; 发布命令12345678910111213141516171819202122232425# 命令mvn deploy:deploy-file## 自定义参数 -Dparam## -DgroupId=项目## -DartifactId=模块## -Dversion=版本号## -Dpackaging=打包方式## -Dfile=本地路径## -Dsources=源码路径## -Durl=仓库地址## -DrepositoryId=指定仓库# 如:mvn deploy:deploy-file \\-DgroupId=com.xyz \\-DartifactId=test \\-Dversion=1.0.0 \\-Dpackaging=jar \\-Dfile=path/name-1.0.0.jar \\-Dsources=path/name-1.0.0-sources.jar \\-Durl=http://ip/nexus/content/repositories/thirdparty/ \\-DrepositoryId=thirdparty# 命令中可以使用 pom 变量，如 -Dversion=$&#123;project.version&#125; Idea 中的配置此后就可以一键发布了。","categories":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/categories/Maven/"},{"name":"命令行","slug":"Maven/命令行","permalink":"http://daiwenzh5.github.io/categories/Maven/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/tags/Maven/"},{"name":"Deploy","slug":"Deploy","permalink":"http://daiwenzh5.github.io/tags/Deploy/"},{"name":"Idea","slug":"Idea","permalink":"http://daiwenzh5.github.io/tags/Idea/"},{"name":"命令行","slug":"命令行","permalink":"http://daiwenzh5.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"OpenConnect Client 使用","slug":"yuque/OpenConnect Client 使用","date":"2021-01-02T09:01:41.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2021/01/02/yuque/OpenConnect Client 使用/","link":"","permalink":"http://daiwenzh5.github.io/2021/01/02/yuque/OpenConnect%20Client%20%E4%BD%BF%E7%94%A8/","excerpt":"需求描述 代替 Cisco 的 AnyConnect 客户端； 可以实现无交互的静默登录；","text":"需求描述 代替 Cisco 的 AnyConnect 客户端； 可以实现无交互的静默登录； 安装1234## 安装源yum install epel-release## 安装客户端yum install openconnect 使用查看帮助详细设置可以查看帮助。 12## 查看帮助openconnect -h 脚本此处使用密码登录，无密码登录需要服务端配合设置证书。为了实现自动输入密码，使用了管理命令，也可以使用 expect 实现自动执行 Shell 的交互操作。 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashserver=服务器地址group=分组名user=用户名password=密码pid_file=pid 文件路径## 登录function login() &#123; if [ `pidof openconnect` ];then echo &quot;已登录&quot; else echo $password | openconnect -b --pid-file=$pid_file --authgroup $group -u $user --no-dtls $server ## 判断启动状态 if [ `pidof openconnect` == `cat $pid_file` ];then echo &quot;登录成功&quot; else echo &quot;登录失败&quot; fi fi&#125;## 退出function logout() &#123; # 通过 pid 结束进程 kill -9 `cat $pid_file` echo &quot;注销成功&quot;&#125;## [] 计算布尔值，需要前后空格## &quot;$1&quot; 防止无参，或空格作为一个整体字符串if [ &quot;$1&quot; == &quot;login&quot; ]; then loginelif [ &quot;$1&quot; == &quot;logout&quot; ]; then logoutelse echo 参数输入错误，支持的命令 login 或 logoutfi 别名在用户或全局环境变量中写入脚本路径的别名，使得脚本可以在当前用户的任意目录中，直接通别名调用。注： 环境变量中可以直接执行脚本（即设置自启）; ~/.bash_profile 用户变量； /etc/profile 全局变量； 123456789## 写入用户变量echo &quot;alias 别名=&#x27;脚本路径&#x27;&quot; &gt;&gt; ~/.bash_profile## 刷新变量source ~/.bash_profile## 执行# 登录别名 login# 注销别名 logout 其他分组指令12345678910111213141516## openconnect 授权指令Authentication: -u, --user=NAME Set login username --no-passwd Disable password/SecurID authentication --non-inter Do not expect user input; exit if it is required --passwd-on-stdin Read password from standard input --authgroup=GROUP Choose authentication login selection -F, --form-entry=FORM:OPT=VALUE Provide authentication form responses -c, --certificate=CERT Use SSL client certificate CERT -k, --sslkey=KEY Use SSL private key file KEY -e, --cert-expire-warning=DAYS Warn when certificate lifetime &lt; DAYS -g, --usergroup=GROUP Set login usergroup -p, --key-password=PASS Set key passphrase or TPM SRK PIN --key-password-from-fsid Key passphrase is fsid of file system --token-mode=MODE Software token type: rsa, totp, hotp or oidc --token-secret=STRING Software token secret or oidc token 异常使用12345678## 指令-g GROUP## 报错Failed to obtain WebVPN cookie## 解决，替换指令--authgroup=GROUP","categories":[{"name":"Linux","slug":"Linux","permalink":"http://daiwenzh5.github.io/categories/Linux/"},{"name":"VPN","slug":"Linux/VPN","permalink":"http://daiwenzh5.github.io/categories/Linux/VPN/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://daiwenzh5.github.io/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"http://daiwenzh5.github.io/tags/Centos/"},{"name":"VPN","slug":"VPN","permalink":"http://daiwenzh5.github.io/tags/VPN/"},{"name":"OpenConnect","slug":"OpenConnect","permalink":"http://daiwenzh5.github.io/tags/OpenConnect/"}]},{"title":"Cloud Toolkit","slug":"yuque/Cloud Toolkit","date":"2020-12-26T19:02:28.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/12/27/yuque/Cloud Toolkit/","link":"","permalink":"http://daiwenzh5.github.io/2020/12/27/yuque/Cloud%20Toolkit/","excerpt":"插件介绍提供自动部署项目到服务器的能力，并且可以在部署前后执行自定义命令或脚本。","text":"插件介绍提供自动部署项目到服务器的能力，并且可以在部署前后执行自定义命令或脚本。 插件使用前提在插件市场安装好插件。 配置服务器 选择 Alibaba Cloud View 面板：在底部（或侧边栏，或顶部 Tools 导航栏）； 点击 Add Host：添加服务 填写服务器 ip：可以填多个，换行分隔，但端口得一致； 指定登录方式：使用 ssh 需要将公钥写入到服务器得 ssh 授权文件中，然后在插件中配置本地私钥路径； 配置启动项 选择 Deploy to Host：在 Target Host 中指定（上步添加的）服务器，可以多选; 选择 Upload File：在（聚合项目）使用过程中，Maven Build 会自动（没找到配置项）上传错误的路径，且上传的是 pom，而 Upload File 可以随意指定路径； 选择 Browse（也可以直接在输入框中填写）：找到打包好的（mvn install 或 target 的）路径； 填写远程服务器中项目发版的根路径； 指定部署前执行命令：点击 + 打开拓展菜单； 选择执行器：此处选择了 maven； 输入执行命令：填入目标（goal）命令即可，多个命令空格（逗号没试）分隔； 后置命令在部署（项目上传到服务器）后（在部署的路径中）执行。推荐在服务器上预置脚本来提供更强、更灵活的功能。 clean.sh因为可能会有不同版本号的项目，且没有在打包插件中约定固定的名称，因此服务器上会积累多个版本项目： 一般的启动脚本（为了忽视版本号），会使用 * 来匹配指定前缀的 jar 以启动项目，如此启动脚本会匹配多个版本的项目，需要清理旧的项目； 或者需要将之前的 jar 包做成备份； 所以需要使用脚本找出旧的项目（此时 jar 已经上传）。 12345678910111213#!/bin/bashfile=&#x27;项目名-*&#x27;# 计算该目录下相同前缀的文件个数num=`ls -tr | grep $&#123;file&#125; | wc -l`echo 共有 $num 个文件if [ $num -gt 1 ];then # 计算需要删除的文件个数（保留一个就行） num=`expr $num - 1` echo 找到历史文件: `ls -tr | grep $&#123;file&#125; | head -$num | xargs` ls -tr | grep file | head -$num | xargs -i -n1 rm -rf &#123;&#125; &amp;&amp; echo 删除成功!else echo 无历史文件，忽略本次操作fi auto-deploy.sh脚本的功能上解耦好一点，因此添加一个统一的入口脚本，用来统筹其他的操作，下面的执行方式需要 .sh 的读取权限，通常 chmod 777 ./xxx.sh 给上足够的权限即可。 12#!/bin/bash./clean.sh &amp;&amp; ./startup.sh 其他 也可以在 VS Code 安装，（我）用来发前端； 更多操作，查看官方介绍 ；","categories":[{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Intellij Plugin","slug":"工具/Intellij-Plugin","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/Intellij-Plugin/"}],"tags":[{"name":"Intellij Plugin","slug":"Intellij-Plugin","permalink":"http://daiwenzh5.github.io/tags/Intellij-Plugin/"},{"name":"运维","slug":"运维","permalink":"http://daiwenzh5.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"自动部署","slug":"自动部署","permalink":"http://daiwenzh5.github.io/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"AnAction","slug":"yuque/AnAction","date":"2020-12-20T05:40:21.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/12/20/yuque/AnAction/","link":"","permalink":"http://daiwenzh5.github.io/2020/12/20/yuque/AnAction/","excerpt":"仅用于记录插件开发时踩的坑 接口介绍","text":"仅用于记录插件开发时踩的坑 接口介绍AnAction 是 Intellij Idea SDK 提供的按钮接口实现下的抽象类，通过继承此类，可以轻易的实现符合 Intellij UI 设计风格的自定义按钮组件。Intellij SDK 中就内置了大量 AnAction 子类，下面是自定义实现的主要重写方法： 12// 按钮点击时执行public abstract void actionPerformed(@NotNull AnActionEvent e); 拓展子类ToggleAction用于表示具有选定状态，且在执行（点击按钮）时切换其选定状态的动作。如控制台日志滚动时的自动换行按钮，以及滚动跟随按钮。 12345// 判断按钮是否被选中public abstract boolean isSelected(@NotNull AnActionEvent e);// 设置按钮何时被设置为选中状态public abstract void setSelected(@NotNull AnActionEvent e, boolean state); 辅助类ActionToolbar工具栏，用于操作控制台的一组按钮。在 Git 面板，如下： 创建方法ActionManager#createActionToolbar(String, ActionGroup, boolean) 1234567891011private void createToolbar() &#123; // 创建一个按钮组 final DefaultActionGroup actions = new DefaultActionGroup(); // 通过 ConsoleView#createConsoleActions() 方法创建默认按钮 actions.addAll(consoleView.createConsoleActions()); // 创建工具栏 ActionToolbar actionToolbar = ActionManager.getInstance() .createActionToolbar(ActionPlaces.TOOLBAR, actions, false); // 添加到控制台 consoleView.getComponent().add(actionToolbar.getComponent()); &#125; 在 ConsoleViewImpl#createConsoleActions() 中提供如下按钮组 注意事项ConsoleView#createConsoleActions 中需要 Editor 组件被初始化，因此需要先执行 ConsoleView#getComponent 方法。","categories":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://daiwenzh5.github.io/categories/Intellij-Idea/"},{"name":"plugin","slug":"Intellij-Idea/plugin","permalink":"http://daiwenzh5.github.io/categories/Intellij-Idea/plugin/"}],"tags":[{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://daiwenzh5.github.io/tags/Intellij-Idea/"},{"name":"plugin","slug":"plugin","permalink":"http://daiwenzh5.github.io/tags/plugin/"},{"name":"swing","slug":"swing","permalink":"http://daiwenzh5.github.io/tags/swing/"},{"name":"java","slug":"java","permalink":"http://daiwenzh5.github.io/tags/java/"}]},{"title":"结果集拦截器","slug":"yuque/结果集拦截器","date":"2020-12-07T12:36:53.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/12/07/yuque/结果集拦截器/","link":"","permalink":"http://daiwenzh5.github.io/2020/12/07/yuque/%E7%BB%93%E6%9E%9C%E9%9B%86%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"需求描述修改已有的结果集，可以对查询的字段与 Java 属性直接进行任意的映射。","text":"需求描述修改已有的结果集，可以对查询的字段与 Java 属性直接进行任意的映射。 实际项目中，为了防止修改表结构而造成锁表，因此采用拓展表放置新的字段，为了不修改原有业务逻辑，故需要使用切面来处理结果集新增的部分字段，将其映射到 Map 中。 解决方案ps: 通过修改 XML 可以完成所有复杂查询，但要考虑到方案适配的通用性，XML ヾ(•ω•`)o。Mybatis 内置的 ResultHandler 拦截器可以对其 ResultMap 对象进行拦截。 关键的数据结构ResultMap 是 Mybatis 的结果集映射对象，与 XML 中 相对应，其中通过 ResultMapping 定义了每一列字段与 Java 属性之间的映射关系，具体数据结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ResultMap &#123; private Configuration configuration; // 唯一标识符 private String id; // 映射类型，Map 或 Java Bean private Class&lt;?&gt; type; // 每一列对应的映射关系 private List&lt;ResultMapping&gt; resultMappings; // 主键的映射关系，有助于生成缓存提升性能，可为空 private List&lt;ResultMapping&gt; idResultMappings; // 构造器映射关系 private List&lt;ResultMapping&gt; constructorResultMappings; // 属性映射关系 private List&lt;ResultMapping&gt; propertyResultMappings; // 被映射的列 private Set&lt;String&gt; mappedColumns; // 被映射的属性 private Set&lt;String&gt; mappedProperties; // 鉴别器，在不同字典值分别使用不同的映射关系时使用 private Discriminator discriminator; // 是否存在嵌套的结果集映射，一对多、一对一时为 true private boolean hasNestedResultMaps; // 是否存在嵌套查询，与 &lt;select/&gt; 标签相对于，存在 N+1 private boolean hasNestedQueries; // 是否自动映射，列名与属性名完全一致时启用可以取消显示映射 private Boolean autoMapping;&#125;private Configuration configuration; // 属性名，Map 的 key 值，或 Java Bean 的属性，自动映射时会按照全局策略转换字符串 // 默认时下划线转小驼峰 private String property; // 列名，该列是嵌套结果集时可以为空，否则需要与属性值一一对应 private String column; // Java 类型 private Class&lt;?&gt; javaType; // Jdbc 类型 private JdbcType jdbcType; // 类型处理器，常用的基本类型可以为空，走内置处理器，对于一些特殊的，如 list（程序） 转 string（数据库）， // 则需要指定自定义的类型处理器，继承 TypeHandler 实现方法即可 private TypeHandler&lt;?&gt; typeHandler; // 嵌套结果集的 Id private String nestedResultMapId; // 嵌套查询的 Id private String nestedQueryId; // 非空列 private Set&lt;String&gt; notNullColumns; // 列前缀，自动拼接在列名前，可以为空 private String columnPrefix; // 主键、构造器标识 private List&lt;ResultFlag&gt; flags; private List&lt;ResultMapping&gt; composites; // 结果集 private String resultSet; // 外键列 private String foreignColumn; // 是否启用懒加载，嵌套查询时生效 private boolean lazy;&#125; 获取 ResultMap 对象ResultMap 可以通过 MappedStatement 获取，且获取的是一个不可修改的 List 集合。因此 ResultMap 的修改要点： 遍历所有结果集映射； 反射重置结果集列表； 123456789101112131415161718public class ResultHanlderInterceptor implements Interceptor &#123; @Override public Object intercept(Invocation invocation) &#123; // 获取默认处理器 DefaultResultSetHandler defaultResultSetHandler = (DefaultResultSetHandler) invocation.getTarget(); // mybatis 元数据对象，辅助工具，屏蔽反射受检异常 MetaObject metaStatementHandler = SystemMetaObject.forObject(defaultResultSetHandler); // 获取映射语句，当前执行 SQL 的所有信息 // 其中存在 List&lt;ResultMap&gt; 属性，每一个 ResultMap 对应一个 Java Bean， // 一般只有一个值，即 SQL 的返回值 MappedStatement mappedStatement = (MappedStatement) metaStatementHandler.getValue(&quot;mappedStatement&quot;); // 处理 ResultMap for (ResultMap resultMap: mappedStatement.getResultMap) &#123; // 重建 ResultMap &#125; &#125;&#125; 重建 ResultMapResultMap 的获取并不复杂，事实上很轻易的就可以拿到，通过调试或者查看源码，可知，通过 getter 方法可以得到列映射关系，ResultMapping，同样这也是不可修改的 List 集合，但不同的是，直接通过反射修改是不会生效的，所有的（列或结果集）映射关系必须要先向 mybatis 的 configuration 注册才行。 123456789101112131415161718192021222324252627282930313233343536373839404142// 重建 ResultMappublic static ResultMap rebuild(MappedStatement ms, ResultMap resultMap) &#123; MapperBuilderAssistant builderAssistant = getMapperBuilderAssistant(ms); // 先获取原有的 ResultMapping 列表，仅对要修改的部分做处理（增、改、删） List&lt;ResultMapping&gt; resultMappings = Lists.newArrayList(resultMap.getResultMappings().iterator()); // 增加一个新的映射 resultMappings.add(getResultMapping()); // 注册 ResultMap 到 configuration ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, &quot;id，唯一标识，不可重复&quot;), resultMap.getType(), null, null, // 将 resultMappings 设为不可变 list Collections.unmodifiableList(resultMappings), 是否自动映射); return resultMapResolver.resolve(); &#125;// 构建一个新的列映射关系public ResultMapping getResultMapping() &#123; return new ResultMapping.Builder(builderAssistant.getConfiguration(), getProperty(&quot;属性名&quot;)) .column(&quot;列名&quot;)) .typeHandler(类型处理器.class) .jdbcType(JdbcType.value)) .javaType(Java 类型.class) .nestedResultMapId(&quot;嵌套的 ResultMap id， 需要先注册&quot;) .build())&#125; /** * 获取映射器构建助手 * * @param ms 映射语句 * @return 映射器构建助手 */ private static MapperBuilderAssistant getMapperBuilderAssistant(MappedStatement ms) &#123; Configuration configuration = ms.getConfiguration(); String resource = ms.getResource(); String nameSpace = ms.getId().substring(0, ms.getId().lastIndexOf(&quot;.&quot;)); MapperBuilderAssistant builderAssistant = new MapperBuilderAssistant(configuration, resource); builderAssistant.setCurrentNamespace(nameSpace); return builderAssistant; &#125; 注意事项 对应 （XML 文件）没有 ResultMap（或使用 ResultType）的结果集，需要设置自动映射（autoMapping = true），否则可能出现属性丢失的问题； 仅仅（通过反射）修改 ResultMap 的 resultMappings 属性不会生效，因为 ResultMapping 用于记录映射关系，却不是 Mybatis Configuration 真实的读取的信息，需要通过 ResultMapResolver 解析器读取信息，并注册到配置中心； 对于使用线程变量做拦截器标记时（如 PageHelper），在最终返回时拦截器结束时需要对线程变量进行 clear，谨防 OOM； 也可以在拦截器中直接读取 ResultSet，手动进行映射，或使用 Json 等工具，最终返回格式化后的对象，但需要考虑到列名与属性名不一样的场景，且对 Mybatis 映射产生破坏（不推荐）； 总结通过修改 ResultMap 可以任意的进行结果集映射，就像在 XML 中定义了 标签一样，但不同的是，其可以通过注解或参数等方式，对某个查询进行标记，可以在运行时动态的修改返回查询结果，且 ResultMap 会被 Mybaits 自动缓存。","categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/categories/Mybatis/"},{"name":"拦截器","slug":"Mybatis/拦截器","permalink":"http://daiwenzh5.github.io/categories/Mybatis/%E6%8B%A6%E6%88%AA%E5%99%A8/"}],"tags":[{"name":"拦截器","slug":"拦截器","permalink":"http://daiwenzh5.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"结果集","slug":"结果集","permalink":"http://daiwenzh5.github.io/tags/%E7%BB%93%E6%9E%9C%E9%9B%86/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/tags/Mybatis/"},{"name":"ResultMap","slug":"ResultMap","permalink":"http://daiwenzh5.github.io/tags/ResultMap/"}]},{"title":"自动发行插件","slug":"yuque/自动发行插件","date":"2020-12-03T17:49:09.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/12/04/yuque/自动发行插件/","link":"","permalink":"http://daiwenzh5.github.io/2020/12/04/yuque/%E8%87%AA%E5%8A%A8%E5%8F%91%E8%A1%8C%E6%8F%92%E4%BB%B6/","excerpt":"需求描述在项目迭代过程中，需要为不同的版本号打上 Tag，对于发行的稳定版本则需要上传到指定的仓库。手动操作则过于繁琐，且无法统一 Tag 的样式，因此需要一款实现自动的可配置的发行工具。","text":"需求描述在项目迭代过程中，需要为不同的版本号打上 Tag，对于发行的稳定版本则需要上传到指定的仓库。手动操作则过于繁琐，且无法统一 Tag 的样式，因此需要一款实现自动的可配置的发行工具。 解决方案使用 maven-release-plugin 插件，其提供了自动追赠版本号、自动切换 snapshots 和 releases 版本、以及自动打 Tag 与版本发行等功能。 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 父模块 pom.xml --&gt;&lt;!-- git 地址 --&gt;&lt;scm&gt; &lt;connection&gt;scm:git:url&lt;/connection&gt; &lt;developerConnection&gt;scm:git:url&lt;/developerConnection&gt; &lt;tag&gt;HEAD&lt;/tag&gt;&lt;/scm&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0-M1&lt;/version&gt; &lt;configuration&gt; &lt;username&gt;scm 用户名&lt;/username&gt; &lt;!-- 对于 github 用户，（当密码无效时）可能需要 repo token 权限（代替密码） --&gt; &lt;password&gt;scm 密码&lt;/password&gt; &lt;scmCommentPrefix&gt;[提交信息的前缀]&lt;/scmCommentPrefix&gt; &lt;!-- 子模块的版本号与父模块是否一致 --&gt; &lt;autoVersionSubmodules&gt;true&lt;/autoVersionSubmodules&gt; &lt;!-- tag 的格式，如 v1.0.0 --&gt; &lt;tagNameFormat&gt;v@&#123;project.version&#125;&lt;/tagNameFormat&gt; &lt;!-- 跳过测试以及生成 javadoc 文档（注释不规范时会报错）--&gt; &lt;arguments&gt;-DskipTests -DuseReleaseProfile=false&lt;/arguments&gt; &lt;!-- tag 的路径，gitee 路径，主要是快 --&gt; &lt;tagBase&gt;https://gitee.com/&#123;用户名&#125;/&#123;项目名&#125;/tags&lt;/tagBase&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;!-- 配置发行路径，这里配置的是阿里云效的私有仓库 --&gt;&lt;!-- 需要在 settings.xml 中配置 server 的用户名和密码，且指定的 id 需要和下面的一致 --&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;rdc-releases&lt;/id&gt; &lt;url&gt;https://packages.aliyun.com/maven/repository/2046382-release-Kot3ui/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;rdc-snapshots&lt;/id&gt; &lt;url&gt;https://packages.aliyun.com/maven/repository/2046382-snapshot-sZVDXF/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt;&lt;!-- settings.xml --&gt; &lt;servers&gt; &lt;server&gt; &lt;!-- id 需要和上面一致 --&gt; &lt;id&gt;rdc-releases&lt;/id&gt; &lt;username&gt;用户名&lt;/username&gt; &lt;password&gt;密码&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;rdc-snapshots&lt;/id&gt; &lt;username&gt;用户名&lt;/username&gt; &lt;password&gt;密码&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 正式发行一定要配置 distributionManagement 且要注意授权信息（账号、密码）是否填写且正确，否则授权无法通过产生 401 异常。 使用123456# 预备发行：打 Tag，自动切换快照版本mvn release:prepare# 将已有的 Tag 发行到指定仓库mvn release:perform# 异常时回滚mvn release:rollback 在 idea 可以通过可视化插件使用，需要注意的时，正式发行前一定要先进行预备发行。且每次打 Tag 时必须要求 git 是最新提交，正式发行使用的是上次 Tag（历史提交） 中的 pom，因此每次修改需要先提交到 git。 注意事项 提交时出现 remote: Invalid username or password，确保自己的登录信息没有错，则尝试使用 repo token 来替换密码； 发布 prepare 之后，会产生各个模块的 pom 备份文件，最好在提交之前加入 .gitignore;","categories":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/categories/Maven/"},{"name":"插件","slug":"Maven/插件","permalink":"http://daiwenzh5.github.io/categories/Maven/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/tags/Maven/"},{"name":"插件","slug":"插件","permalink":"http://daiwenzh5.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"发版","slug":"发版","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%91%E7%89%88/"},{"name":"Tag","slug":"Tag","permalink":"http://daiwenzh5.github.io/tags/Tag/"}]},{"title":"聚合项目版本号管理","slug":"yuque/聚合项目版本号管理","date":"2020-12-03T14:13:46.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/12/03/yuque/聚合项目版本号管理/","link":"","permalink":"http://daiwenzh5.github.io/2020/12/03/yuque/%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E5%8F%B7%E7%AE%A1%E7%90%86/","excerpt":"需求描述在 Maven 聚合工程中，通常修改版本号是一件较为繁琐的过程，特别是子模块较多时，复制粘贴也得谨防遗漏，因此需要一款自动化工具，来完成机械的工作。","text":"需求描述在 Maven 聚合工程中，通常修改版本号是一件较为繁琐的过程，特别是子模块较多时，复制粘贴也得谨防遗漏，因此需要一款自动化工具，来完成机械的工作。 解决方案插件 versions-maven-plugin 正是用来解决这类痛点。 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 父模块 pom.xml --&gt;&lt;groupId&gt;xxx&lt;/groupId&gt;&lt;artifactId&gt;yyy&lt;/artifactId&gt;&lt;version&gt;a.b.c&lt;/version&gt;&lt;!-- 聚合子项目 --&gt;&lt;modules&gt; &lt;module&gt;模块-A&lt;/module&gt; &lt;module&gt;模块-B&lt;/module&gt; &lt;module&gt;模块-C&lt;/module&gt; &lt;module&gt;模块-D&lt;/module&gt;&lt;/modules&gt;&lt;!-- 统一子模块版本号，$&#123;project.version&#125; 为父项目版本号 --&gt;&lt;!-- 子模块相互依赖时无需指定版本号 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;模块-A&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 引入插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;versions-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/plugin&gt;&lt;!-- 子模块 pom.xml --&gt;&lt;!-- parent 填入完整的父项目信息 --&gt;&lt;parent&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;yyy&lt;/artifactId&gt; &lt;version&gt;a.b.c&lt;/version&gt;&lt;/parent&gt; idea 中可以通过 Maven 插件栏选中 versions:set，快速设置。在运行窗口填写版本号即可。","categories":[{"name":"maven","slug":"maven","permalink":"http://daiwenzh5.github.io/categories/maven/"},{"name":"聚合项目","slug":"maven/聚合项目","permalink":"http://daiwenzh5.github.io/categories/maven/%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://daiwenzh5.github.io/tags/maven/"},{"name":"聚合项目","slug":"聚合项目","permalink":"http://daiwenzh5.github.io/tags/%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE/"},{"name":"版本更新","slug":"版本更新","permalink":"http://daiwenzh5.github.io/tags/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"},{"name":"version","slug":"version","permalink":"http://daiwenzh5.github.io/tags/version/"}]},{"title":"Mybatis XML 新增异常","slug":"yuque/Mybatis XML 新增异常","date":"2020-11-27T14:40:46.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/11/27/yuque/Mybatis XML 新增异常/","link":"","permalink":"http://daiwenzh5.github.io/2020/11/27/yuque/Mybatis%20XML%20%E6%96%B0%E5%A2%9E%E5%BC%82%E5%B8%B8/","excerpt":"异常信息12345678org.springframework.dao.DataIntegrityViolationException:### Error updating database. Cause: java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value### The error may exist in file [xxx.xml]### The error may involve xxxMapper.insert-Inline### The error occurred while setting parameters### SQL: insert into xxx create_time ) values ( ?, ?, ?, ?, ? )### Cause: java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value; Field &#x27;id&#x27; doesn&#x27;t have a default value; nested exception is java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value","text":"异常信息12345678org.springframework.dao.DataIntegrityViolationException:### Error updating database. Cause: java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value### The error may exist in file [xxx.xml]### The error may involve xxxMapper.insert-Inline### The error occurred while setting parameters### SQL: insert into xxx create_time ) values ( ?, ?, ?, ?, ? )### Cause: java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value; Field &#x27;id&#x27; doesn&#x27;t have a default value; nested exception is java.sql.SQLException: Field &#x27;id&#x27; doesn&#x27;t have a default value 解决方案原因：插入时没有指定 id，且数据库没有自增主键。处理：在 xml 中添加 &lt;if test=&quot;id != null&quot;&gt;id,&lt;/if&gt; 手动设置 id；或者在数据库中设置自增。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://daiwenzh5.github.io/categories/mybatis/"},{"name":"xml","slug":"mybatis/xml","permalink":"http://daiwenzh5.github.io/categories/mybatis/xml/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://daiwenzh5.github.io/tags/mybatis/"},{"name":"xml","slug":"xml","permalink":"http://daiwenzh5.github.io/tags/xml/"},{"name":"insert","slug":"insert","permalink":"http://daiwenzh5.github.io/tags/insert/"},{"name":"主键","slug":"主键","permalink":"http://daiwenzh5.github.io/tags/%E4%B8%BB%E9%94%AE/"}]},{"title":"多字段联合校验","slug":"yuque/多字段联合校验","date":"2020-11-18T07:01:31.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/11/18/yuque/多字段联合校验/","link":"","permalink":"http://daiwenzh5.github.io/2020/11/18/yuque/%E5%A4%9A%E5%AD%97%E6%AE%B5%E8%81%94%E5%90%88%E6%A0%A1%E9%AA%8C/","excerpt":"tags: [参数校验,@GroupSequenceProvider,hibernate validator,Bean Validation]categories: [springboot,参数校验]","text":"tags: [参数校验,@GroupSequenceProvider,hibernate validator,Bean Validation]categories: [springboot,参数校验] 场景描述在使用进行数据校验时，经常会遇到需要多个字段组合式的校验。例如 某个嘉年华俱乐部门票对不同人群存在不同的定价： 年龄必须大于 12 岁； 12 ~ 18 岁半价； 18 岁以上全价； coser 则可以免费； 换句话来说，任何年龄大于 12 岁的人都可以购买全价，对于半价票需要校验年龄是否满足未成年，对于免费票需要校验是否是 coser。 实现方案入场时，需要根据门票类型动态的切换校验分组，定义如下的 Person 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Getter@Setter@GroupSequenceProvider(Person.FareTypeGroupSequenceProvider.class)public class Person &#123; /** * 年龄 */ @Min(value = 12, message = &quot;年龄最小不低于 12 岁&quot;) @Max(value = 18, message = &quot;年龄大于 18 岁需要购买全价门票&quot;, groups=WhenIsHalf.class) private Integer age; /** * 票价[0=免费,1=半价,2=全价] */ @NotNull(message = &quot;票价类型不能为空&quot;) private Integer fareType; /** * 是否是 coser */ @AssertTrue(message = &quot;只有 coser 才可以免费进去&quot;, groups = WhenIsFree.class) private Boolean coser; public interface WhenIsFree &#123;&#125; public interface WhenIsHalf &#123;&#125; /** * 校验分组处理器 */ public static class FareTypeGroupSequenceProvider implements DefaultGroupSequenceProvider&lt;Person&gt; &#123; @Override public List&lt;Class&lt;?&gt;&gt; getValidationGroups(Person person) &#123; ArrayList&lt;Class&lt;?&gt;&gt; list = Lists.newArrayList(); list.add(Person.class); // 判空 if (Objects.nonNull(person)) &#123; // 当 fareType = 0 时 if (Objects.equals(person.getFareType(), 0)) &#123; list.add(WhenIsFree.class); &#125; else (Objects.equals(person.getFareType(), 1)) &#123; list.add(WhenIsHalf.class); &#125; &#125; return list; &#125; &#125;&#125; 注意事项 DefaultGroupSequenceProvider 类型是泛型类，必须指定为需要参数校验的 Bean 类型； DefaultGroupSequenceProvider.getValidationGroups 方法返回的 list 中必须包含 Bean 类型; DefaultGroupSequenceProvider 只能增强 Default.class 分组;","categories":[],"tags":[]},{"title":"HttpMediaTypeNotAcceptableException","slug":"yuque/HttpMediaTypeNotAcceptableException","date":"2020-10-22T08:49:07.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/10/22/yuque/HttpMediaTypeNotAcceptableException/","link":"","permalink":"http://daiwenzh5.github.io/2020/10/22/yuque/HttpMediaTypeNotAcceptableException/","excerpt":"异常描述导出 Excel 时产生异常，提示：Could not find acceptable representation。","text":"异常描述导出 Excel 时产生异常，提示：Could not find acceptable representation。 123456789101112131415161718192021222324252627282930313233343536373839org.springframework.web.HttpMediaTypeNotAcceptableException: Could not find acceptable representation at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:307) at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:180) at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:122) at org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver.doResolveHandlerMethodException(ExceptionHandlerExceptionResolver.java:412) at org.springframework.web.servlet.handler.AbstractHandlerMethodExceptionResolver.doResolveException(AbstractHandlerMethodExceptionResolver.java:61) at org.springframework.web.servlet.handler.AbstractHandlerExceptionResolver.resolveException(AbstractHandlerExceptionResolver.java:140) at org.springframework.web.servlet.handler.HandlerExceptionResolverComposite.resolveException(HandlerExceptionResolverComposite.java:79) at org.springframework.web.servlet.DispatcherServlet.processHandlerException(DispatcherServlet.java:1298) at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1110) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1056) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) at javax.servlet.http.HttpServlet.service(HttpServlet.java:645) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:712) at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:580) at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:516) at org.apache.catalina.core.StandardHostValve.custom(StandardHostValve.java:388) at org.apache.catalina.core.StandardHostValve.status(StandardHostValve.java:253) at org.apache.catalina.core.StandardHostValve.throwable(StandardHostValve.java:348) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:173) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:853) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1587) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) 解决方案向 response 中写入流时，接口不能存在 json 格式的返回值。将返回值改成 void 即可解决问题。","categories":[],"tags":[]},{"title":"消费者","slug":"yuque/消费者","date":"2020-08-26T08:10:22.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/08/26/yuque/消费者/","link":"","permalink":"http://daiwenzh5.github.io/2020/08/26/yuque/%E6%B6%88%E8%B4%B9%E8%80%85/","excerpt":"需求描述接手了一个陈年的 dubbo 项目，现准备抽离某个模块，以前的聚合工程太大了，不想动，就另起了一个项目作为消费者调用之前的服务。之前只在聚合项目中进行服务互调，现在两个项目之间完全独立，只通过 dubbo 交互，因此出现了一些问题，在此记录一下。","text":"需求描述接手了一个陈年的 dubbo 项目，现准备抽离某个模块，以前的聚合工程太大了，不想动，就另起了一个项目作为消费者调用之前的服务。之前只在聚合项目中进行服务互调，现在两个项目之间完全独立，只通过 dubbo 交互，因此出现了一些问题，在此记录一下。 注解@Refrence属性服务消费者引用服务注解。提供了大量的配置属性，实际上使用时，只需标记注解，所有属性采用默认设置即可。对于消费者而言，期望的是开箱即用的服务，因此服务提供者应该应该装配合理的默认属性，避免消费者进行不透明操作。 接口@Reference 不能直接标注在接口上，其提供远程服务自动注入功能，类似于 @Autowired、@Resource 注解，应在类属性字段或 setter 方法上使用。接口的类限定名必须和服务提供者一致，否则出现无法获取服务的异常。注意：interfaceName 属性指定的接口名并不会生效。 1Failed to check the status of the service &lt;ServiceName&gt;. No provider available for the service &lt;ServiceName&gt; from the url zookeeper:&#x2F;&#x2F;&lt;URL&gt; to the consume &lt;IP&gt; use dubbo version 2.7.6 同样，接口暴露的参数的类限定名必须和服务提供者一致，否则会出现序列化异常的报错。 12org.apache.dubbo.remoting.RemotingException: Fail to decode request due to: RpcInvocation [methodName&#x3D;&lt;MethodName&gt;, parameterTypes&#x3D;null, arguments&#x3D;null, attachments&#x3D;&#123;path&#x3D;&lt;ServiceName&gt;, input&#x3D;348, dubbo&#x3D;2.0.2, version&#x3D;0.0.0&#125;] 实际上消费端错误信息并不是很清晰，通过服务端日志，可以看到是在 rpc 解析时出现类无法找到的异常，该类 是接口参数。 123[New I&#x2F;O worker #10] WARN c.a.d.r.p.d.DecodeableRpcInvocation [Slf4jLogger.java : 62] [DUBBO] Decode rpc invocation failed: Read invocation data failed.java.lang.ClassNotFoundException: &lt;ServiceName&gt; @EnableDubbo用于启用 dubbo 服务，需要指定接口的包名提供扫描。","categories":[{"name":"微服务","slug":"微服务","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"dubbo","slug":"微服务/dubbo","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://daiwenzh5.github.io/tags/dubbo/"},{"name":"springboot","slug":"springboot","permalink":"http://daiwenzh5.github.io/tags/springboot/"},{"name":"踩坑日记","slug":"踩坑日记","permalink":"http://daiwenzh5.github.io/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"}]},{"title":"页面加载优化","slug":"yuque/页面加载优化","date":"2020-08-14T13:21:23.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/08/14/yuque/页面加载优化/","link":"","permalink":"http://daiwenzh5.github.io/2020/08/14/yuque/%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/","excerpt":"GZIP 压缩1npm install compression-webpack-plugin --save-dev","text":"GZIP 压缩1npm install compression-webpack-plugin --save-dev 123const CompressionPlugin = require(&quot;compression-webpack-plugin&quot;);// 使用cfg.plugins.push(new CompressionPlugin()); ES6 压缩使用 terser-webpack-plugin 插件对 es6 语法的 js 文件进行压缩。 1npm install terser-webpack-plugin --save-dev 1234567891011121314const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);// 使用cfg.plugins.push( new TerserPlugin(&#123; cache: true, parallel: true, sourceMap: true, terserOptions: &#123; compress: &#123; drop_debugger: true, &#125;, &#125;, &#125;)); 注意：使用 UglifyJs 打包会报错。提示不能识别 const 等 ES6 的语法： 1Unexpected token: keyword «const» [js/vendor.58d16842.js:46032,0]","categories":[],"tags":[]},{"title":"装饰器","slug":"yuque/装饰器","date":"2020-08-13T05:06:06.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/08/13/yuque/装饰器/","link":"","permalink":"http://daiwenzh5.github.io/2020/08/13/yuque/%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"使用理解在 JavaScript 中，装饰器的作用可以类比 Java 的注解。但其更多的类似于 AOP 语法糖，因为其本身不需要指定处理器，装饰器在定义时即可对目标进行环绕增强，可以有效地剥离出与业务无关的模板代码，减少冗余。其本质上是一个特定类型的函数，通过 @函数名 的方式使用。","text":"使用理解在 JavaScript 中，装饰器的作用可以类比 Java 的注解。但其更多的类似于 AOP 语法糖，因为其本身不需要指定处理器，装饰器在定义时即可对目标进行环绕增强，可以有效地剥离出与业务无关的模板代码，减少冗余。其本质上是一个特定类型的函数，通过 @函数名 的方式使用。 装饰器类型12345678910111213141516171819202122232425interface TypedPropertyDescriptor&lt;T&gt; &#123; enumerable?: boolean; configurable?: boolean; writable?: boolean; value?: T; get?: () =&gt; T; set?: (value: T) =&gt; void;&#125;declare type ClassDecorator = &lt;TFunction extends Function&gt;( target: TFunction) =&gt; TFunction | void;declare type PropertyDecorator = ( target: Object, propertyKey: string | symbol) =&gt; void;declare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;declare type ParameterDecorator = ( target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void; 通过 TypeScript 的声明文件，可以清晰的看到装饰器类型定义，对于不同类型的装饰器，其方法参数总是固定的且通过上下文注入。换言之，装饰器本身是不支持的自定义参数的，为了突破这一限制，通常使用工厂模式，即通过工厂函数接收参数，并返回一个装饰器函数。 装饰器工厂上文提到，工厂模式并不是装饰器的过度设计，而是对其本身功能的再次加强，是为了提供可自定义入参。下面是一个方法装饰器工厂的一般形式。 12345678910111213141516171819202122// 方法装饰器工厂function methodDecoratorFactory(msg: string) &#123; // do something...(预处理) return funtion(target: Object, propertyKey: string, decorator: TypedPropertyDescriptor&lt;any&gt;) &#123; // 记录原方法 const fn = decorator.value; // 重新定义方法，使用装饰器环绕原方法 // 不能使用箭头函数，否则会丢失上下文（this 会指向箭头函数） decorator.value = function() &#123; // 前置处理 // arguments 需要解构传入，否则会将原参数包装成数组 // 或 使用 fn.apply(this. arguments) const result = fn.call(this, ...arguments) // 后置处理 // 必须返回原方法结果，否则会丢失结果 return result; &#125; return decorator; &#125;&#125; 实践意义日志装饰器记录方法的入参、出参以及执行时间。 12345678910111213141516171819202122232425262728293031323334353637export function log(hander?: Function) &#123; const loggerInfo = Object.seal(&#123; method: &quot;&quot;, input: &quot;&quot;, output: &quot;&quot;, custom: &quot;&quot;, timeuse: &quot;&quot;, &#125;); // 一个用于记录使用时间的对象 const timeUse = TimeUse.get(); return function ( target: Object, key: string, descriptor: TypedPropertyDescriptor&lt;any&gt; ): TypedPropertyDescriptor&lt;any&gt; &#123; const oldValue = descriptor.value; descriptor.value = async function () &#123; loggerInfo.method = key; const args: Array&lt;any&gt; = []; for (let index in arguments) &#123; args.push(arguments[index]); &#125; loggerInfo.input = args.join(&quot;,&quot;); // 执行原方法 const value = await oldValue.apply(this, arguments); loggerInfo.output = value; hander &amp;&amp; (loggerInfo.custom = hander(loggerInfo.input, loggerInfo.output) || &quot;&quot;); // 被调用时，会自动发出一个事件 loggerInfo.timeuse = `$&#123;timeUse.off()&#125;ms`; console.debug(loggerInfo); return value; &#125;; return descriptor; &#125;;&#125; 加载装饰器在异步请求数据时显示加载动画。 12345678910111213141516171819202122export const loading = function (message: string) &#123; return function ( target: Object, propertyKey: string, decorator: TypedPropertyDescriptor&lt;any&gt; ) &#123; // 记录原方法 const fn = decorator.value; decorator.value = async function () &#123; try &#123; // Loading 是 UI 框架中的加载动画 Loading.show(&#123; message &#125;); const resp = await fn.apply(this, arguments); return resp; &#125; finally &#123; // 此时需要在 finally 关闭动画，防止异常时被阻塞 Loading.hide(); &#125; &#125;; return decorator; &#125;;&#125;; 注意事项装饰器只能在类及其成员属性上使用，不能作用在静态方法（类方法）上。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"http://daiwenzh5.github.io/categories/Typescript/"},{"name":"装饰器","slug":"Typescript/装饰器","permalink":"http://daiwenzh5.github.io/categories/Typescript/%E8%A3%85%E9%A5%B0%E5%99%A8/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://daiwenzh5.github.io/tags/Typescript/"},{"name":"Javascript","slug":"Javascript","permalink":"http://daiwenzh5.github.io/tags/Javascript/"},{"name":"注解","slug":"注解","permalink":"http://daiwenzh5.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"装饰器","slug":"装饰器","permalink":"http://daiwenzh5.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"}]},{"title":"MapStruct 未生效","slug":"yuque/MapStruct 未生效","date":"2020-07-23T10:36:49.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/07/23/yuque/MapStruct 未生效/","link":"","permalink":"http://daiwenzh5.github.io/2020/07/23/yuque/MapStruct%20%E6%9C%AA%E7%94%9F%E6%95%88/","excerpt":"问题描述无法找不到实现类 Cannot find implementation。","text":"问题描述无法找不到实现类 Cannot find implementation。 解决方案1. 包含 Swagger 依赖在项目中使用了 swagger，需要将其中的 mapstruct 排除后，重新在 pom 中添加。 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 重新引入： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt;&lt;/dependency&gt;","categories":[],"tags":[]},{"title":"Oracle 误删数据恢复","slug":"yuque/Oracle 误删数据恢复","date":"2020-06-17T08:20:31.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/06/17/yuque/Oracle 误删数据恢复/","link":"","permalink":"http://daiwenzh5.github.io/2020/06/17/yuque/Oracle%20%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/","excerpt":"DELETE 误删方案Oracle 提供闪回，在数据被删除后还没有进行大量操作（被删除数据的块没有被覆写），即可通过闪回方式直接找回删除的数据。","text":"DELETE 误删方案Oracle 提供闪回，在数据被删除后还没有进行大量操作（被删除数据的块没有被覆写），即可通过闪回方式直接找回删除的数据。 步骤 确认数据删除时间； select * from 表名 as of timestamp to_timestamp(&#39;时间&#39;,&#39;yyyy-mm-dd hh24:mi:ss&#39;)，可查询出该表的历史数据； insert into 表明 (查询 sql)，可将查询出的数据直接插入到表中；","categories":[{"name":"数据库","slug":"数据库","permalink":"http://daiwenzh5.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"http://daiwenzh5.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://daiwenzh5.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://daiwenzh5.github.io/tags/sql/"}]},{"title":"Hexo 自动提取摘要","slug":"yuque/Hexo 自动提取摘要","date":"2020-06-08T02:23:33.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/06/08/yuque/Hexo 自动提取摘要/","link":"","permalink":"http://daiwenzh5.github.io/2020/06/08/yuque/Hexo%20%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E6%91%98%E8%A6%81/","excerpt":"目的通过添加 &lt;!-- more --&gt; 标记，可以手动切割文章，实现在列表页面仅显示文章摘要。但像这样在文章内部手动添加标记的方法，对文章进行了侵入式的改造，添加了与内容实际无关的信息，并不是很理想。为了能够实现自动添加摘要，可以通过现有的 hexo 插件来实现，如：hexo-excerpt，hexo-auto-excerpt。但两者各自存在一定的局限，并不能很好的实现预期的效果，因此必须手动对其插件代码进行改造。","text":"目的通过添加 &lt;!-- more --&gt; 标记，可以手动切割文章，实现在列表页面仅显示文章摘要。但像这样在文章内部手动添加标记的方法，对文章进行了侵入式的改造，添加了与内容实际无关的信息，并不是很理想。为了能够实现自动添加摘要，可以通过现有的 hexo 插件来实现，如：hexo-excerpt，hexo-auto-excerpt。但两者各自存在一定的局限，并不能很好的实现预期的效果，因此必须手动对其插件代码进行改造。 插件对比hexo-excerpt：作用在生成器执行过程中，通过 dom 树自动提取文章内容，摘要提取相对完整灵活，但是只能作用在首页列表；hexo-auto-excerpt：作用在文章后置过滤器执行过程中，通过指定固定的字符数自动提取文章内容，可以为所用列表项添加摘要； 插件实现在参考了上述两个插件的源码之后，发现将其实现机制组合起来，可以有效的解决当前的痛点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const htmlparser = require(&quot;htmlparser2&quot;);const domutils = require(&quot;domutils&quot;);const defaults = require(&quot;lodash.defaults&quot;);// hexo-excerpt 中提供的方法，具体见下文const Filter = require(&quot;./lib/dom-filter&quot;);const DEFAULT_CONFIG = &#123; depth: 2, excerpt_excludes: [], more_excludes: [], hideWholePostExcerpts: false,&#125;;// 注册过滤器，参考 hexo-auto-excerpthexo.extend.filter.register(&quot;after_post_render&quot;, excerpt);// 全局参数let excerptFilter;let moreFilter;let opts;/** * 提取文章摘要, 此部分提取自 hexo-excerpt * @param &#123;Document&#125; post 文章 */function excerpt(post) &#123; init(); //honour the &lt;!-- more --&gt; !!! if ( /&lt;!--\\s*more\\s*--&gt;/.test(post.content) || post.content.indexOf(&#x27;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&#x27;) !== -1 ) &#123; return post; &#125; let nodes = []; let parser = new htmlparser.Parser( new htmlparser.DomHandler((err, dom) =&gt; &#123; if (!err) &#123; nodes = dom; &#125; &#125;), &#123; decodeEntities: false, &#125; ); parser.write(post.content); parser.done(); // tracks how many tag nodes we found let stopIndex = 1; // tracks how many nodes we found in total let index = 0; for (; index &lt; nodes.length &amp;&amp; stopIndex &lt;= opts.depth; index++) &#123; if (nodes[index].type === &quot;tag&quot; &amp;&amp; excerptFilter.match(nodes[index])) &#123; stopIndex++; &#125; &#125; // set correct excerpt and more nodes values let excerptNodes = nodes.slice(0, index); let moreNodes = nodes.slice(index); // filter nodes excerptNodes = excerptFilter.filter(excerptNodes); moreNodes = moreFilter.filter(moreNodes); // If the hideWholePostExcerpts option is set to true (the default), don&#x27;t show // excerpts for short posts (i.e. ones where the excerpt is the whole post) if (moreNodes.length != 0 || !opts.hideWholePostExcerpts) &#123; post.excerpt = excerptNodes .map((node) =&gt; domutils.getOuterHTML(node)) .join(&quot;&quot;); post.more = moreNodes.map((node) =&gt; domutils.getOuterHTML(node)).join(&quot;&quot;); &#125; return post;&#125;/** * 初始化配置 */function init() &#123; const config = hexo.config; let legacy = &#123;&#125;; if (config.excerpt_depth) &#123; hexo.log.warn( &quot;excerpt_depth is deprecated, please use excerpt.depth instead.&quot; ); legacy.depth = config.excerpt_depth; &#125; opts = opts || defaults(&#123;&#125;, config.excerpt, legacy, DEFAULT_CONFIG); opts.depth = parseInt(opts.depth); if (!Array.isArray(opts.excerpt_excludes)) opts.excerpt_excludes = [opts.excerpt_excludes]; if (!Array.isArray(opts.more_excludes)) opts.more_excludes = [opts.more_excludes]; excerptFilter = excerptFilter || new Filter(hexo, opts.excerpt_excludes); moreFilter = moreFilter || new Filter(hexo, opts.more_excludes);&#125; 12345678910111213141516171819202122232425262728293031323334353637const domutils = require(&quot;domutils&quot;);const CSSselect = require(&quot;css-select&quot;);function Filter(hexo, excludes) &#123; this.hexo = hexo; this.selectors = excludes.map(this._compile.bind(this));&#125;Filter.prototype._compile = function (selector) &#123; try &#123; return CSSselect.compile(selector); &#125; catch (err) &#123; this.hexo.log.error( &quot;hexo-excerpt: Ignore invalid CSS selector: &quot; + selector ); return (n) =&gt; false; &#125;&#125;;Filter.prototype.match = function (node) &#123; // not match any return !this.selectors.some((s) =&gt; s(node));&#125;;Filter.prototype.filter = function (nodes) &#123; // remove inner nodes that doesn&#x27;t match domutils .filter((n) =&gt; !this.match(n), nodes) .forEach((node) =&gt; &#123; domutils.removeElement(node); &#125;); // only keep top level nodes that match return nodes.filter(this.match.bind(this));&#125;;module.exports = Filter; 其他不完备方法一开始是查看 hexo-excerpt 的源码，准备在标签页生成期处理，参考 hexo-generator-tag 的实现过程，最终可以实现在标签页提取摘要，但对于分类页面，仍然需要做相同的处理，随即放弃，此处仅作记录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const pagination = require(&quot;hexo-pagination&quot;);hexo.extend.generator.register(&quot;tag&quot;, generator);function generator(db) &#123; const config = this.config; const perPage = config.tag_generator.per_page; const paginationDir = config.pagination_dir || &quot;page&quot;; const orderBy = config.tag_generator.order_by || &quot;-date&quot;; const tags = db.tags; let tagDir; init(); const pages = tags.reduce((result, tag) =&gt; &#123; if (!tag.length) return result; const posts = tag.posts.sort(orderBy); // 预处理 posts，提取摘要，excerpt 方法定义在上文 posts.data = posts.data.map(excerpt); const data = pagination(tag.path, posts, &#123; perPage: perPage, layout: [&quot;tag&quot;, &quot;archive&quot;, &quot;index&quot;], format: paginationDir + &quot;/%d/&quot;, data: &#123; tag: tag.name, &#125;, &#125;); return result.concat(data); &#125;, []); // generate tag index page, usually /tags/index.html if (config.tag_generator.enable_index_page) &#123; tagDir = config.tag_dir; if (tagDir[tagDir.length - 1] !== &quot;/&quot;) &#123; tagDir += &quot;/&quot;; &#125; pages.push(&#123; path: tagDir, layout: [&quot;tag-index&quot;, &quot;tag&quot;, &quot;archive&quot;, &quot;index&quot;], // posts: db.posts, data: &#123; base: tagDir, total: 1, current: 1, current_url: tagDir, // posts: db.posts, prev: 0, prev_link: &quot;&quot;, next: 0, next_link: &quot;&quot;, tags: tags, &#125;, &#125;); &#125; return pages;&#125; 辅助在研究时为了查看 hexo 的 post 具体的结构定义的打印函数，尝试过程中，并没有找到如何进行调试，因此将其打印后查看。 1234567891011121314151617181920212223/** * 文章属性打印 * 查看其文章结构 * @param &#123;Document&#125; document 文章 */function documentPrint(document) &#123; if (document instanceof Array) &#123; console.log(&quot;documentPrint ====== begin&quot;); document.forEach((item) =&gt; documentPrint(item)); console.log(&quot;documentPrint ====== end&quot;); return; &#125; for (const key in document) &#123; if (document.hasOwnProperty(key)) &#123; const value = document[key]; if (!&quot;more、_content、raw&quot;.includes(key)) &#123; console.log(&quot;====&gt; %o: %o&quot;, key, value); &#125; else &#123; console.log(&quot;====&gt; %o: %o&quot;, key, &quot;[blog]&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"边缘技术","slug":"边缘技术","permalink":"http://daiwenzh5.github.io/categories/%E8%BE%B9%E7%BC%98%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"边缘技术/前端","permalink":"http://daiwenzh5.github.io/categories/%E8%BE%B9%E7%BC%98%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://daiwenzh5.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://daiwenzh5.github.io/tags/blog/"},{"name":"excerpt","slug":"excerpt","permalink":"http://daiwenzh5.github.io/tags/excerpt/"},{"name":"语雀编辑器","slug":"语雀编辑器","permalink":"http://daiwenzh5.github.io/tags/%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8/"}]},{"title":"git remote fail","slug":"yuque/git remote fail","date":"2020-06-01T02:03:50.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/06/01/yuque/git remote fail/","link":"","permalink":"http://daiwenzh5.github.io/2020/06/01/yuque/git%20remote%20fail/","excerpt":"异常描述在使用 git fetch 等命令同步远程仓库时失败：","text":"异常描述在使用 git fetch 等命令同步远程仓库时失败： 12remote: The project you were looking for could not be found.fatal: repository &#x27;远程仓库地址&#x27; not found 解决方案原因：username 不匹配。登录的错误的用户名或密码，或者使用 vpn 连接时，vpn 账号和 git 账号不匹配。可以通过查看凭据管理器检查 git 的用户名和密码，并将其修改成正确的信息。Windows 路径：控制面板\\所有控制面板项\\凭据管理器","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://daiwenzh5.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"windows","slug":"版本控制/windows","permalink":"http://daiwenzh5.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/windows/"}],"tags":[{"name":"git","slug":"git","permalink":"http://daiwenzh5.github.io/tags/git/"},{"name":"windows","slug":"windows","permalink":"http://daiwenzh5.github.io/tags/windows/"}]},{"title":"Hexo 博客搭建","slug":"yuque/Hexo 博客搭建","date":"2020-05-11T14:39:30.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/05/11/yuque/Hexo 博客搭建/","link":"","permalink":"http://daiwenzh5.github.io/2020/05/11/yuque/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"文章摘要为了在列表页面隐藏全文，实现“阅读全文”的折叠按钮，需要在 md 文件上手动添加标记 &lt;!-- more --&gt;，对文件本身产生了侵入，更好的方式是通过 npm install hexo-excerpt --save 插件，来实现自动根据目录层级生成摘要。","text":"文章摘要为了在列表页面隐藏全文，实现“阅读全文”的折叠按钮，需要在 md 文件上手动添加标记 &lt;!-- more --&gt;，对文件本身产生了侵入，更好的方式是通过 npm install hexo-excerpt --save 插件，来实现自动根据目录层级生成摘要。 12345excerpt: depth: 2 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true 文章路径默认的路径中若包含中文，将会生成又臭又长的一段字符串，影响阅读体验。使用 npm install hexo-abbrlink --save 插件，可以自动地将文章标题映射成一串短字符串。 1234567# 源路径生成跪在，:key 表示动态值# permalink: :year/:month/:day/:title/permalink: :year/:month/:day/:abbrlink.html## 启用算法生成不重复文件编号abbrlink: alg: crc132 #算法： crc16(default) and crc32 rep: hex # dec为十进制，hex为十六进制 RSS 订阅RSS 虽然小众，却能带来很好的阅读体验，因为订阅的权力是面向读者的，且不会有广告之类的阅读干扰。使用 npm install hexo-generator-feed --save 插件可以自动生成支持 RSS 订阅的 XML 文件。 1234feed: type: atom path: atom.xml limit: 20 PWA 支持hexo-service-worker 插件安装1npm install hexo-service-worker --save 介绍该插件是 hexo-offline 的改进版，具有相同的配置以及更强的功能。同样，我在其仓库的文档中并没有找到 sw.js 的配置入口，因此采用了手动注册（sw.js）的方式。 配置12345678910111213141516171819202122232425262728### _config.ymlimport: # meta: # ... link: - &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot;&gt; - &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; script: - &lt;script src=&quot;/sw-register.js&quot;/&gt; - &lt;script src=&quot;/sw.js&quot;/&gt;# offline config passed to sw-precache.service_worker: maximumFileSizeToCacheInBytes: 5242880 staticFileGlobs: - public/**/*.&#123;js,html,css,png,jpg,gif,svg,eot,ttf,woff,woff2&#125; stripPrefix: public verbose: true ## 缓存策略，支持列表 runtimeCaching: - urlPattern: /**/* handler: cacheFirst options: origin: imgchr.com - urlPattern: /**/* handler: cacheFirst options: origin: cdn.jsdelivr.net 资源sw-register.jssw.js需要注意此文件头部的变量（用于定义要缓存的资源），可能要调整。 hexo-pwa 插件 不想降级 hexo， 已放弃使用的改插件了，/(ㄒ o ㄒ)/~~ 安装1npm install hexo-pwa --save bash 介绍该插件已经年久失修了， 上次提交 23429d1（截止 2020-03-21），该插件尚且不兼容 hexo@4.2.0，降级后可正常使用。 插件地址 1234# 查看版本hexo -version# 安装指定版本npm install hexo@4.1.1 --save 配置需要指定 manifest.json 文件及 sw.js 文件的相对（根）路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546pwa: manifest: path: /manifest.json body: name: &quot;名称&quot; short_name: &quot;短名称&quot; theme_color: &quot;主题颜色，标题栏颜色&quot; background_color: &quot;背景色&quot; display: &quot;standalone&quot; Scope: &quot;/&quot; start_url: &quot;/&quot; icons: - src: /images/logos/48.png sizes: 48x48 type: image/png - src: /images/logos/96.png sizes: 96x96 type: image/png - src: /images/logos/128.png sizes: 128x128 type: image/png - src: /images/logos/144.png sizes: 144x144 type: image/png - src: /images/logos/192.png sizes: 192x192 type: image/png - src: /images/logos/512.png sizes: 512x512 type: image/png serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5 图标需要不同尺寸的图标，推荐使用 svg 图片导出不同尺寸，白嫖的 Logo 设计网站：生成好图片后，F12 打开“元素”面板，选中图片，复制出 svg 标签使用 TXT 文本另存为 logo.svg。此时可以使用 AI 来处理，矢量图的好处就是可以无损的进行放大（于 2020-05-12）。 清单需要添加 manifest.json 到 sources 目录下，并在模板中手动引用。 123import: link: - &quot;&lt;link rel=&#x27;manifest&#x27; href=&#x27;/manifest.json&#x27;&gt;&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;name&quot;: &quot;名称&quot;, &quot;short_name&quot;: &quot;短名称&quot;, &quot;theme_color&quot;: &quot;主题色，标题栏颜色&quot;, &quot;background_color&quot;: &quot;背景色&quot;, &quot;display&quot;: &quot;standalone&quot;, &quot;Scope&quot;: &quot;/&quot;, &quot;start_url&quot;: &quot;/&quot;, &quot;icons&quot;: [ &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;48x48&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;96x96&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;128x128&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot; &#125;, &#123; &quot;src&quot;: &quot;相对 sources 的图片地址&quot;, &quot;sizes&quot;: &quot;512x512&quot;, &quot;type&quot;: &quot;image/png&quot; &#125; ], &quot;splash_pages&quot;: null&#125; 脚本需要添加 sw.js 到 sources 目录下。 12345678910111213141516171819202122232425262728293031323334353637const workboxVersion = &quot;5.0.0&quot;;importScripts( `https://storage.googleapis.com/workbox-cdn/releases/$&#123;workboxVersion&#125;/workbox-sw.js`);if (workbox) &#123; workbox.setConfig(&#123; modulePathPrefix: `https://storage.googleapis.com/workbox-cdn/releases/$&#123;workboxVersion&#125;`, &#125;); workbox.precaching.precache([&quot;/&quot;, &quot;/index.html&quot;]); workbox.routing.registerRoute( new RegExp(&quot;^https?://博客地址/?$&quot;), workbox.strategies.networkFirst() ); workbox.routing.registerRoute( new RegExp(&quot;.*.html&quot;), workbox.strategies.networkFirst() ); workbox.routing.registerRoute( new RegExp(&quot;.*.(?:js|css)&quot;), workbox.strategies.staleWhileRevalidate() ); workbox.routing.registerRoute( new RegExp(&quot;https://imgchr.com/&quot;), workbox.strategies.cacheFirst() ); workbox.routing.registerRoute( new RegExp(&quot;https://cdn.jsdelivr.net/&quot;), workbox.strategies.cacheFirst() );&#125; 语雀文章获取使用参加插件官方配置 标签使用语雀本身的 🔖（标签组件）只会被渲染成普通的字符串，必须通过手动添加 front-matter 才可以。 1234tags: [标签 1, 标签 2]categories: [一级分类, 二级分类]--- 在语雀中，可以配合 🔖 字符串形式，如本文中使用方式： 图片防盗链处理添加 &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt; 到模板 head 可解决。 1234# blog/_config.ymlimport: meta: - &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt; 参见插件官方 issue","categories":[{"name":"前端","slug":"前端","permalink":"http://daiwenzh5.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"http://daiwenzh5.github.io/categories/%E5%89%8D%E7%AB%AF/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://daiwenzh5.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://daiwenzh5.github.io/tags/Blog/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://daiwenzh5.github.io/tags/Github-Pages/"},{"name":"语雀","slug":"语雀","permalink":"http://daiwenzh5.github.io/tags/%E8%AF%AD%E9%9B%80/"}]},{"title":"🕷 统一异常处理","slug":"yuque/🕷 统一异常处理","date":"2020-04-23T11:02:43.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/23/yuque/🕷 统一异常处理/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/23/yuque/%F0%9F%95%B7%20%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"🚩 需求描述将接口访问所有异常进行统一处理。在业务逻辑编写时，应该将所有可预知的异常定义好，并设定唯一的错误代码，在异常发生时，通过统一的返回值自动包装，提供给前端优化的错误提示，并能够通过错误代码快速定位异常类型。","text":"🚩 需求描述将接口访问所有异常进行统一处理。在业务逻辑编写时，应该将所有可预知的异常定义好，并设定唯一的错误代码，在异常发生时，通过统一的返回值自动包装，提供给前端优化的错误提示，并能够通过错误代码快速定位异常类型。 🐘 异常对象定义一个业务层异常，用于抛出业务逻辑上的异常错误。 123456789101112131415161718@Getter@AllArgsConstructor(access = AccessLevel.PRIVATE)public class ServiceException extends RuntimeException &#123; /** * 错误信息 */ public final String message; /** * 错误代码 */ public final String code; public static ServiceException of(ExceptionEnum exceptionEnum) &#123; return new ServiceException(exceptionEnum.code, exceptionEnum.message); &#125;&#125; 其中 ExceptionEnum 类是用于描述异常的枚举类型，定义异常的错误代码及错误信息。 123456@AllArgsConstructorpublic enum ExceptionEnum &#123; ; public final String code; public final String message;&#125; 📄 代码实现通过 @RestControllerAdive 提升作用域，通过 @ExceptionHandler 注解来处理不同的异常。 🔢 业务层异常所有的业务逻辑错误触发的异常。 12345678910/** * 处理业务异常 * * @param exception 异常 * @return 统一返回值 */@ExceptionHandler(ServiceException.class)public RestResponse&lt;String&gt; handleServiceException(ServiceException exception) &#123; return RestResponse.error(exception.code, exception.message);&#125; ⁉ 未知异常用于捕捉其他的所有不可预知的错误，可能是表字段的数据异常，导致数据库在更新时无法动态的生成 SQL（在编写时默认该值不为空，但被人为删除了），而产生的 dao 层异常，也有可能时系统资源被占用，导致文件无法写入的 IO 异常，不可控制的网络超时异常等等。 12345678910/** * 其他未知的所有异常 * * @param exception 异常 * @return 统一返回值 */ @ExceptionHandler(Exception.class) public RestResponse&lt;String&gt; handleOtherException(Exception exception) &#123; return RestResponse.error(exception.getMessage()); &#125; 🔐 参数校验异常需要使用 @Validated 注解标记在 Controller 的类、方法或参数上。对于验证规则，使用 javax.validation.constraints 和 org.hibernate.validator.constraints 包中的规则注解。具体使用此处不细究，仅对异常的处理进行展开。该异常表现为接口访问错误，但具体的错误提示信息并未写入到响应，服务端异常信息如下： 12javax.validation.ConstraintViolationException: common.msg: 消息不能为空...异常堆栈信息 可以建立一个指定异常为 ConstraintViolationException 的处理器，用于封装参数错误的异常信息。 1234@ExceptionHandler(ConstraintViolationException.class)public RestResponse&lt;String&gt; constraintViolationExceptionHandler(ConstraintViolationException e) &#123; return RestResponse.error(((ConstraintViolation) e.getConstraintViolations().toArray()[0]).getMessage());&#125; 其中 ConstraintViolation 可能不止一个参数校验的结果，取第（任）一个即可。 🔍 404 异常尽管 Spring 默认实现了 /error（即接口访问出错）情况下的处理，（在 Postman 上随手输出一个接口，模拟 404）如： 1234567&#123; &quot;timestamp&quot;: &quot;2020-01-07T16:37:31.160+0000&quot;, &quot;status&quot;: 404, &quot;error&quot;: &quot;Not Found&quot;, &quot;message&quot;: &quot;No message available&quot;, &quot;path&quot;: &quot;/123&quot;&#125; 但在某些时候，需要针对错误访问进行特殊的处理，此时可以实现 ErrorController 接口进行自定义拓展。如下对 4xx、5xx 系列的错误状态进行处理： 1234567891011@RequestMapping(&quot;error&quot;)public RestResponse&lt;Object&gt; errorHandle(HttpServletRequest request) &#123; HttpStatus status = getStatus(request); if (status.is4xxClientError()) &#123; return RestResponse.error(&quot;客户端访问出错&quot;); &#125; if (status.is5xxServerError()) &#123; return RestResponse.error(&quot;服务器访问异常&quot;); &#125; return RestResponse.error(&quot;未知异常&quot;);&#125; 当然，在条件分支中，对某个具体的状态做判断，可以更细致化的处理不同的访问错误。 其他方法 在 @Exception 中进行状态判断，对错误请求做处理； （未测试）在资源目录（/resources/public/error）下添加错误访问页面，命名为 404.html、500.html 等； （未测试）配置 EmbeddedServletContainerCustomizer 实现；","categories":[],"tags":[]},{"title":"📑 统一日志记录","slug":"yuque/📑 统一日志记录","date":"2020-04-23T10:07:48.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/23/yuque/📑 统一日志记录/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/23/yuque/%F0%9F%93%91%20%E7%BB%9F%E4%B8%80%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","excerpt":"🚩 需求描述能够在每次访问接口时，自动记录入参、出参的全局统一日志。","text":"🚩 需求描述能够在每次访问接口时，自动记录入参、出参的全局统一日志。 📈 方案与分析说明：日志作用的所有接口上，且需要统一形式，因此是不考虑在接口中手写的。 📋 方案一理想的情况下是通过 spring aop 快速进入开发状态，然后在打包时通过 aspectj 处理器在编译期织入代码。因为 spring aop 采用 aspectj 语法，且提供了强大但简单的注解支持，因此可以很轻松的实现切面。但是 spring 的 aop 是运行时的（反射），相对于静态织入的 aspectj 来说，性能差距是极大的。而使用 aspectj 处理器每次需要手动清除之前编译的代码，否则新的代码无法实时编译的，比较麻烦，因此比较适合在打包时提供 aspectj 编译处理 📋 方案二spring 其他内置增强接口， @RestControllerAdive，可以为注解类提升作用域，而 ResponseBodyAdive，RequestBodyAdive 接口，则可以为实现类提供预处理出参、入参的接口数据，两相结合，则可以实现类似的环绕式的出入参日志记录 📋 方案三使用拦截器或过滤器，但其匹配规则是作用在 url 上，粒度太大不够细致。 📄 代码实现此处通过 aop 实现，需要注意的是，若通过 ResponseBodyAdive 接口来处理统一返回值，则不能使用 @Around 的环绕切面，因为该切面要求方法的出参类型是不能修改的，而使用被统一返回类型包装的对象，是与切面方法的实际返回值是不一样的，故下面使用 @Before、@AfterReturning 方法分别处理接口入参、和参数两个状态。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Aspect@Component@Slf4jpublic class LogProcessor &#123; /** * 记录日志信息 */ @AllArgsConstructor private static class LogInfo &#123; /** * 请求 id */ String requestId; /** * 开始时间 */ long startTime; /** * gson 工具 */ Gson gson; &#125; ThreadLocal&lt;LogInfo&gt; logInfo = new ThreadLocal&lt;&gt;(); @Pointcut(value = &quot;@annotation(com.包名.annotation.Log)&quot;) private void point() &#123; &#125; /** * 方法执行前 * * @param joinPoint 切点 */ @Before(value = &quot;point()&quot;) public void LogRequestInfo(JoinPoint joinPoint) &#123; String uuid = UUID.randomUUID().toString(); Gson gson = new Gson(); // 缓存线程变量信息 logInfo.set(new LogInfo(uuid, System.currentTimeMillis(), gson)); ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = Objects.requireNonNull(attributes).getRequest(); StringBuilder requestLog = new StringBuilder(); Signature signature = joinPoint.getSignature(); requestLog.append(&quot;[&quot;).append(uuid).append(&quot;] -&gt; &quot;) .append(&quot;请求信息：&quot;).append(&quot;URL = &#123;&quot;).append(request.getRequestURI()).append(&quot;&#125;, &quot;) .append(&quot;请求方式 = &#123;&quot;).append(request.getMethod()).append(&quot;&#125;, &quot;) .append(&quot;请求IP = &#123;&quot;).append(request.getRemoteAddr()).append(&quot;&#125;, &quot;) .append(&quot;类方法 = &#123;&quot;).append(signature.getDeclaringTypeName()).append(&quot;.&quot;) .append(signature.getName()).append(&quot;&#125;, &quot;); // 处理请求参数 String[] paramNames = ((MethodSignature) signature).getParameterNames(); Object[] paramValues = joinPoint.getArgs(); int paramLength = null == paramNames ? 0 : paramNames.length; if (paramLength == 0) &#123; requestLog.append(&quot;请求参数 = &#123;&#125; &quot;); &#125; else &#123; requestLog.append(&quot;请求参数 = [&quot;); for (int i = 0; i &lt; paramLength - 1; i++) &#123; requestLog.append(paramNames[i]).append(&quot;=&quot;).append(gson.toJson(paramValues[i])).append(&quot;,&quot;); &#125; requestLog.append(paramNames[paramLength - 1]).append(&quot;=&quot;).append(gson.toJson(paramValues[paramLength - 1])).append(&quot;]&quot;); &#125; log.info(requestLog.toString()); &#125; /** * 方法执行后 * * @param target 结果 */ @AfterReturning(returning = &quot;target&quot;, pointcut = &quot;point()&quot;) public void logResultVOInfo(Object target) &#123; LogInfo logInfo = this.logInfo.get(); // 删除线程变量 this.logInfo.remove(); long offTime = System.currentTimeMillis() - logInfo.startTime; log.info(String.format(&quot;[%s] -&gt; 请求结果：%s [%dms]&quot;, logInfo.requestId, logInfo.gson.toJson(target), offTime)); &#125;&#125; 因为实际上，两个切面方法是独立的作用域，为了线程安全，故使用线程变量来存储请求的日志信息，主要记录该请求的唯一编号（此处使用 UUID），开始时间，同时又都需要将对象 json 化，所以也缓存了 gson 对象。同样的方法，也可以通过实现增强接口，重写其预处理入参、出参的方法来提供日志支持。 java spring log web aop","categories":[],"tags":[]},{"title":"MongoDB 使用记录","slug":"yuque/MongoDB 使用记录","date":"2020-04-15T05:28:30.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/15/yuque/MongoDB 使用记录/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/15/yuque/MongoDB%20%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"⚙ 配置mongo 默认是无认证登录的，即使在设置用户名和密码后，也是需要手动修改配置文件开启授权认证。当然，在开启授权之前，应该连接数据库，创建必要的用户账户。","text":"⚙ 配置mongo 默认是无认证登录的，即使在设置用户名和密码后，也是需要手动修改配置文件开启授权认证。当然，在开启授权之前，应该连接数据库，创建必要的用户账户。 💾 连接数据库直接使用 Navicat 连接即可，初始时选择无验证连接。成功连接之后若未显示任何数据库，则选择连接之后，在顶部导航栏选中【查看】-【显示隐藏的项目】，之后可以看到默认的数据库 admin、config、local 等。 🆔 创建账户选择 admin 数据库，新建查询，创建一个超级用户（用户之后连接登录认证的）。 1234567db.createUser( &#123; user:&quot;root&quot;, pwd:&quot;root&quot;, roles:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;] &#125;); 也可以创建其他数据库，并设置相应的角色，但需注意，空的数据库默认是不会保存的，因此在新建数据库之后，应该写入一条临时数据。 12--- 插入任意数据，之后可以删除db.[数据库名].insert(&#123;&#x27;key&#x27;: &#x27;value&#x27;&#125;) ✍ 修改配置开启授权验证。 123456# 编辑配置文件vim /etc/mongod.conf-----# 启用权限控制security: authorization: enabled 😨 一个意外删库宣言 仅以此纪念我消逝的数据 👀All your data is a backed up. You must pay 0.015 BTC to 1Dy28zwYdyPYzWjGzuRLJeGeiEabG61AFZ 48 hours for recover it. After 48 hours expiration we will leaked and exposed all your data. Also do not forget about GDPR. You can buy bitcoin here, does not take much time to buy https://localbitcoins.com with this guide https://localbitcoins.com/guides/how-to-buy-bitcoins After paying write to me in the mail with your DB IP: &#x67;&#x33;&#116;&#x5f;&#98;&#97;&#x73;&#x65;&#x40;&#x70;&#x72;&#111;&#116;&#111;&#x6e;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;“ 您的所有数据都已备份。您必须支付 0.015 BTC 才能花费 48 小时恢复。48 小时到期后，我们将泄露并暴露您的所有数据。也不要忘记 GDPR。你可以在这里购买比特币，不需要花太多时间购买 https://localbitcoins.com 使用本指南 https://localbitcoins.com/guides/how-to-buy-bitcoins 付款后，请用您的 DB IP 给我写信: &#x67;&#x33;&#116;&#95;&#98;&#x61;&#115;&#x65;&#64;&#112;&#114;&#x6f;&#x74;&#x6f;&#110;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;” ⚔ 常用命令1234service mongod &lt;指令&gt;重启 restart启动 start停止 stop mongodb 4.2.5 配置 安装","categories":[],"tags":[]},{"title":"🐘 统一返回对象","slug":"yuque/🐘 统一返回对象","date":"2020-04-14T08:45:30.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/14/yuque/🐘 统一返回对象/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/14/yuque/%F0%9F%90%98%20%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/","excerpt":"🚩 需求描述封装统一的接口返回对象，使得前端能够获取格式规整的数据。","text":"🚩 需求描述封装统一的接口返回对象，使得前端能够获取格式规整的数据。 📦 封装对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class RestResponse&lt;T&gt; implements Serializable &#123; private String code; private T data; private boolean success; private String message; /** * 获取统一返回类型 * * @param code 返回码 * @param data 返回数据 * @param success 返回结果 * @param message 提示信息 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; of(String code, T data, boolean success, String message) &#123; return new RestResponse&lt;&gt;(code, data, success, message); &#125; /** * 返回操作成功的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = true &lt;/p&gt; * * @param code 返回码 * @param data 返回数据 * @param message 提示信息 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; success(String code, T data, String message) &#123; return of(code, data, true, message); &#125; /** * 返回操作成功的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = true &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#code&#125; = 0 &lt;/p&gt; * * @param data 返回数据 * @param message 提示信息 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; success(T data, String message) &#123; return success(&quot;0&quot;, data, message); &#125; /** * 返回操作成功的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = true &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#code&#125; = 0 &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#message&#125; = 响应成功 &lt;/p&gt; * * @param data 返回数据 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; success(T data) &#123; return success(data, &quot;响应成功&quot;); &#125; /** * 返回操作失败的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = false &lt;/p&gt; * * @param code 返回码 * @param data 返回数据 * @param message 提示信息 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; error(String code, T data, String message) &#123; return of(code, data, false, message); &#125; /** * 返回操作成功的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = false &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#data&#125; = null &lt;/p&gt; * * @param message 提示信息 * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; error(String code, String message) &#123; return error(code, null, message); &#125; /** * 返回操作成功的统一类型 * &lt;p&gt; &#123;@link RestResponse#success&#125; = true &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#code&#125; = -1 &lt;/p&gt; * &lt;p&gt; &#123;@link RestResponse#data&#125; = null &lt;/p&gt; * * @param &lt;T&gt; 数据类型 * @return &#123;@code RestResponse&#125; 统一返回类型 */ public static &lt;T&gt; RestResponse&lt;T&gt; error(String message) &#123; return error(&quot;-1&quot;, message); &#125;&#125; 🏗 实现基础spring 中提供了 ResponseBodyAdvice 接口，用于 http 请求在写入响应流之前的处理，为统一返回对象提供了相对便捷的实现方法。 1234567891011121314151617181920212223242526272829public interface ResponseBodyAdvice&lt;T&gt; &#123; /** * Whether this component supports the given controller method return type * and the selected &#123;@code HttpMessageConverter&#125; type. * @param returnType the return type * @param converterType the selected converter type * @return &#123;@code true&#125; if &#123;@link #beforeBodyWrite&#125; should be invoked; * &#123;@code false&#125; otherwise */ boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType); /** * Invoked after an &#123;@code HttpMessageConverter&#125; is selected and just before * its write method is invoked. * @param body the body to be written * @param returnType the return type of the controller method * @param selectedContentType the content type selected through content negotiation * @param selectedConverterType the converter type selected to write to the response * @param request the current request * @param response the current response * @return the body that was passed in or a modified (possibly new) instance */ @Nullable T beforeBodyWrite(@Nullable T body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response);&#125; 方法名 作用 supports() 通过判断响应返回值类型及消息转换器的类型决定是否启用该组件 beforeBodyWrite() 当组件启用时，该方法返回值将作为最终的响应数据写入到流 🔜 流程 创建一个实现 ResponseBodyAdvice 接口的类； 在 supports() 中跳过已经封装过（即类型已经是 RestResponse）的返回值，避免多次封装； 在 beforeBodyWrite() 方法中进行统一返回类型的封装； 📄 实现代码12345678910111213141516171819202122232425262728@Overridepublic boolean supports(MethodParameter returnType, Class converterType) &#123; // 当返回值类型已经时包装类时跳过 return !returnType.getParameterType().equals(RestResponse.class);&#125;@Overridepublic Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; // 1、处理无返回值（即 void）类型的方法 if (returnType.getParameterType().equals(Void.class)) &#123; return RestResponse.success(new Object()); &#125; // 2、Spring 默认使用 StringHttpMessageConverter 处理 String 类型的返回值 // 一旦被包装成统一对象后，不能被转换成字符串，而产生类型转换异常 - 见下方注① if (body instanceof String) &#123; // 2.1、用于重置字符串的响应类型为 application/json response.getHeaders().setContentType(MediaType.APPLICATION_JSON); // 2.2 将统一对象转换成 json 字符串 return JSON.toJSONString(RestResponse.success(body)); &#125; // 3、其他所有情况 return RestResponse.success(body);&#125; ☝ 注意事项注 ①：需要对 String 类型的返回值进行额外的处理，因为 Spring 通过返回值类型来决定消息转换器的选择，所以 String 类型的返回值会默认使用 StringHttpMessageConverter 处理器，但是在 beforeBodyWrite() 处理后，其类型被修改为 RestResponse，因此无法进行转换，出现如下报错： 1com.example.bean.RestResponse cannot be cast to java.lang.String 为了能够处理 String 类型返回值，此处将其封装成统一类型之后再次使用 Json 转换器将其转换成 Json 字符串，最终将向响应流写入如下格式的数据： 1&#123;&quot;code&quot;:&quot;0&quot;,&quot;data&quot;:&quot;收到消息: 123&quot;,&quot;message&quot;:&quot;响应成功&quot;,&quot;success&quot;:true&#125; 使用 Postman 表现形式为不支持格式化的字符串，因为其 Content-Type：application/json，所以此处通过 response.getHeaders().setContentType(MediaType.APPLICATION_JSON); 强制将响应类型标记为 Json 格式。 123456&#123; &quot;code&quot;: &quot;0&quot;, &quot;data&quot;: &quot;收到消息: 123&quot;, &quot;message&quot;: &quot;响应成功&quot;, &quot;success&quot;: true&#125; 💪 功能增强任何类都可以实现 ResponseBodyAdvice 接口，但是为了使其产生预期效果，需要了解其作用范围，默认仅为该类本身，也就是说，若由 Controller 实现，则仅对该控制器生效。因此该接口通常配合 @ControllerAdvice 注解使用。 🍂 其他📩 消息转换器Spring 向响应流写入数据是通过消息转换器（实现 HttpMessageConverter 接口）来处理的，其默认实现了一系列转换器，链式的处理返回值，直到能够正常写入响应流 。对于复杂类型默认使用MappingJackson2HttpMessageConverter 处理器，将复杂类型转换为 Json 格式的字符串，对于字符串类型默认使用 StringHttpMessageConverter 处理器。 ControllerAdvice 注解 Java bean web spring","categories":[],"tags":[]},{"title":"Maven 多环境打包","slug":"yuque/Maven 多环境打包","date":"2020-04-10T12:13:02.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/10/yuque/Maven 多环境打包/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/10/yuque/Maven%20%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/","excerpt":"📃 需求描述项目在开发时需要进行多环境部署打包，每个环境间的配置信息并不互通，若要进行人为的手动替换，不但增加了机械且额外的工作量，还容易出错，因此需要通过配置 Maven，使得能够为不同环境打包不同的配置信息。","text":"📃 需求描述项目在开发时需要进行多环境部署打包，每个环境间的配置信息并不互通，若要进行人为的手动替换，不但增加了机械且额外的工作量，还容易出错，因此需要通过配置 Maven，使得能够为不同环境打包不同的配置信息。 🙋 解决方案🗃 resources 目录📁 目录配置在 resource 目录下添加 env 目录，用于放置不同的环境，如开发环境、测试环境，在 env 下创建 dev、test 目录即可。 1234resources └── env ├── dev └── test 当然，文件名可以为任意有效字符，但需要语义清楚，并与 pom 中指定路径相对应。 ⚙ Maven 配置在 pom 中添加环境属性，与 env 中创建的环境目录相应。 12345678910111213141516171819202122232425262728&lt;profiles&gt; &lt;!-- 开发环境--&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/env/dev&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;!-- 默认激活 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/env/test&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; &lt;/profile&gt;&lt;/profiles&gt; 此时，在 idea 侧边的 maven 插件中的 Profiles 已经可以看到可选环境。 🔧 细节处理此处会将 env 目录也一同打包，但实际上在这打包后已经是无用文件了，因此需要将其剔除。 123456789101112131415&lt;build&gt; &lt;!--打包之后不包含 env --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;**/env/**&lt;/exclude&gt; &lt;!-- 同名的文件无法被覆盖，需要在此排除，比如： 一些文件（spring 的配置文件）是在开发时必须引用且放置在根目录（resources）下，即不能删除 --&gt; &lt;exclude&gt;application-xxx.yml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 📰 webapps 目录📁 目录配置同样，需要现在 webapps 目录下为不同的环境配置不同的文件路径，如下 prod 、test 分别表示生产和测试环境。 1234webapps └── env ├── prod └── test ⚙ Maven 配置与之前的不同的是，webapps 下面的文件需要借助 maven-war-plugin 插件。 123456789101112131415161718192021&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- webapp 中需要排除的文件，此处去除掉存放环境配置的目录 --&gt; &lt;warSourceExcludes&gt; env/test/**,env/prod/** &lt;/warSourceExcludes&gt; &lt;!-- 在 webapp 中需要动态加载的资源 --&gt; &lt;webResources&gt; &lt;resource&gt; &lt;!-- 指定加载路径 --&gt; &lt;directory&gt;src/main/webapp/env/$&#123;active&#125;&lt;/directory&gt; &lt;!-- 相对于 webapp 的目录 --&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;!-- 是否过滤, 开启后会将匹配到的 directory 中的文件替换到 targetPath 中 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt;&lt;/plugin&gt; 🚩 注意为了实现多环境配置，此处在 directory 中，使用了变量 active 来动态匹配路径。至于其值则是通过各个环境的配置文件定义的。 12345678910111213141516171819&lt;profiles&gt; &lt;profile&gt; &lt;!-- 测试环境 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;active&gt;test&lt;/active&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;!-- 生产环境 --&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;active&gt;prod&lt;/active&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt;&lt;/profiles&gt; 此处并没有为每个环境直接指定路径，而是设置了一个 key 为 active 的属性，其 value 对应各自环境的文件夹名。","categories":[{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/categories/Maven/"},{"name":"插件","slug":"Maven/插件","permalink":"http://daiwenzh5.github.io/categories/Maven/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"多环境","slug":"多环境","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%8E%AF%E5%A2%83/"},{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/tags/Maven/"},{"name":"插件","slug":"插件","permalink":"http://daiwenzh5.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"发版","slug":"发版","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%91%E7%89%88/"}]},{"title":"Spring 项目打包后运行报错","slug":"yuque/Spring 项目打包后运行报错","date":"2020-04-09T13:58:50.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/09/yuque/Spring 项目打包后运行报错/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/09/yuque/Spring%20%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/","excerpt":"问题描述使用 IDE 编译可正常运行，但是打包之后在运行时报错：","text":"问题描述使用 IDE 编译可正常运行，但是打包之后在运行时报错： 1java.lang.ClassNotFoundException: com.fasterxml.jackson.core.TSFBuilder 分析及解决表面上是无法找到 jackson 中的某个类，但是在确认过 pom 后发现该依赖已经添加。实际上是因为当前引用的 jackson 依赖与 spring 版本不兼容。 12345# 之前的配置jackson 2.9.2 &lt;----&gt; spring 5.2.5 ✖# 修正之后jackson 2.10.3 &lt;----&gt; spring 5.2.5 ✔ 调整版本号可正常运行。","categories":[],"tags":[]},{"title":"Vue Ts 中使用 axios","slug":"yuque/Vue Ts 中使用 axios","date":"2020-04-07T12:34:54.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/04/07/yuque/Vue Ts 中使用 axios/","link":"","permalink":"http://daiwenzh5.github.io/2020/04/07/yuque/Vue%20Ts%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20axios/","excerpt":"问题描述在使用 typescript 编写 Vue 时无法识别 axios 的类型。在指定类型声明文件后依然无效。","text":"问题描述在使用 typescript 编写 Vue 时无法识别 axios 的类型。在指定类型声明文件后依然无效。 123456789101112import &#123; AxiosInstance &#125; from &quot;axios&quot;;declare module &quot;Vue/types/vue&quot; &#123; interface Vue &#123; $axios: AxiosInstance; &#125;&#125;// 在原型链上挂载Vue.prototype.$axios = axios;// 无法识别类型this.$axios; 解决方案安装 vue-axios 插件。 12345import axios from &quot;axios&quot;;import VueAxios from &quot;vue-axios&quot;;Vue.use(VueAxios, axios);// 消除报错this.axios;","categories":[],"tags":[]},{"title":"插件式注解","slug":"yuque/插件式注解","date":"2020-03-24T12:19:22.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/03/24/yuque/插件式注解/","link":"","permalink":"http://daiwenzh5.github.io/2020/03/24/yuque/%E6%8F%92%E4%BB%B6%E5%BC%8F%E6%B3%A8%E8%A7%A3/","excerpt":"其前身是来自 java 6 的 APT （abstract processor tool），自 java 8 之后被插件式注解 API （pluggable annotation processing api） 取代。其本质上是提供用户在编译器访问注解元数据，处理和自定义编译输出，并能够创建新的源文件等等。 目的","text":"其前身是来自 java 6 的 APT （abstract processor tool），自 java 8 之后被插件式注解 API （pluggable annotation processing api） 取代。其本质上是提供用户在编译器访问注解元数据，处理和自定义编译输出，并能够创建新的源文件等等。 目的 用于生成模板代码，减少工作量，并保证了实际源码的简洁（如：lombok）； 取代大量通过反射处理注解的方式，提高代码的运行性能（如：对象的序列化）； 应用 MapStruct：java bean 映射注解处理器； 代码实现插件式注解是通过继承虚注解处理器（AbstractProcessor）来实现的，通过在其核心方法 （process）中匹配相应注解，可以实现在编译时向项目中输出 java 源文件。 01.注解创建注解 “@Hello”。 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Hello &#123;&#125; 02.处理器创建名为 “HelloProcessor”的处理器，并指定其支持的源码为 java 8，处理上述注解（ “@Hello”）。 123456789101112131415161718192021222324252627282930@SupportedSourceVersion(SourceVersion.RELEASE_8)@SupportedAnnotationTypes(&quot;com.example.annotation.Hello&quot;)public class HelloProcessor extends AbstractProcessor &#123; private static final String HELLO_TEMPLATE = &quot;package %1$s;\\n\\npublic class %2$sHello &#123;\\n public static void sayHello() &#123;\\n System.out.println(\\&quot;Hello %3$s\\&quot;);\\n &#125;\\n&#125;\\n&quot;; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; roundEnvironment.getElementsAnnotatedWith(Hello.class).forEach(element -&gt; &#123; TypeElement typeElem = (TypeElement) element; String typeName = typeElem.getQualifiedName().toString(); Filer filer = processingEnv.getFiler(); try (Writer sw = filer.createSourceFile(typeName + &quot;Hello&quot;).openWriter()) &#123; log(&quot;生成 &quot; + typeName + &quot;Hello 源码&quot;); int lastIndex = typeName.lastIndexOf(&#x27;.&#x27;); sw.write(String.format(HELLO_TEMPLATE, typeName.substring(0, lastIndex), typeName.substring(lastIndex + 1), typeName)); &#125; catch (IOException e) &#123; processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, e.getMessage()); &#125; &#125;); return true; &#125; private void log(String msg) &#123; if (processingEnv.getOptions().containsKey(&quot;debug&quot;)) &#123; processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, msg); &#125; &#125;&#125; 03.作用凡是被 “@Hello” 标记的类，都会生成以其类名 + Hello 形式的类，该类仅有一个类方法（sayHello）。在 Person 类上标记注解，如下： 12@Hellopublic class Person 04.效果最终在 【模块名】\\target\\generated-sources\\annotations 下生成如下类： 12345public class PersonHello &#123; public static void sayHello() &#123; System.out.println(&quot;Hello com.example.bean.Person&quot;); &#125;&#125; 配置01.Maven 编译插件通过在 maven-compiler-plugin 插件中指定注解处理器。在多模块中，可以仅仅在需要提供注解处理器支持的模块中添加配置，亦可在父模块中添加（为所有子模块支持）。但实际上，注解处理器的代码在编译完成（生成源文件）之后，就已经完成其使命，因此在其他模块中，使用 provided 引用，在编译时会排除该依赖。 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;processor&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!--指定源文件生成路径，默认为当前模块下 --&gt;&lt;!-- &lt;generatedSourcesDirectory&gt;$&#123;project.build.directory&#125;/generated-sources/&lt;/generatedSourcesDirectory&gt;--&gt; &lt;annotationProcessors&gt; &lt;annotationProcessor&gt; com.example.processor.HelloProcessor &lt;/annotationProcessor&gt; &lt;/annotationProcessors&gt; &lt;/configuration&gt;&lt;/plugin&gt; 问题无法支持 lombok 插件。与其一起使用，会出现如下报错： 1java: 找不到符号 02.Java 服务注册通过 spi 服务注册的方式。当然需要添加（注解处理器的模块）依赖。在注解处理器所在模块（或项目中）的 resources，创建 javax.annotation.processing.Processor 文件，目录结构如下： 12345resources └── META-INF └── services ├── java.lang.Process └── javax.annotation.processing.Processor 在此文件中，填写自定义的注解处理器（如上面的）：com.example.processor.HelloProcessor。（实测）该方法兼容 lombok 插件。 额外的配置直接注册会产生注解处理器无法找到的错误： 12Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.1:compile (default-compile) on project processor: Compilation failure服务配置文件不正确, 或构造处理程序对象javax.annotation.processing.Processor: Provider com.example.processor.HelloProcessor not found时抛出异常错误 此时需要在该模块下配置 maven-compiler-plugin 插件： 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;3.8.1&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;&#x2F;source&gt; &lt;target&gt;1.8&lt;&#x2F;target&gt; &lt;!-- 不加这一句编译会报找不到processor的异常--&gt; &lt;compilerArgument&gt;-proc:none&lt;&#x2F;compilerArgument&gt; &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt; 问题在其他博客中提到，可以使用 google 的 AutoService 注解，为注解处理器自动生成服务注册文件。但是在实际测试时，发现其所生成的文件名为：java.lang.process，与上述不符，且并不能为注解提供注解处理器的支持。 注意注解处理器在编译器生成代码，因此在使用（生成的代码）时需要先编译，使用 maven 插件 compiler（或 javac 命令）进行编译，最终可以得到此效果。 其他下面是用于生成 builder 类的注解及处理器： 1234@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Builder &#123;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687@SupportedAnnotationTypes(&quot;com.example.Builder&quot;)@SupportedSourceVersion(SourceVersion.RELEASE_8)public class BuilderProcessor extends AbstractProcessor &#123; private Filer filer; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; filer = processingEnv.getFiler(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; System.out.println(&quot;Processing &quot; + annotations + roundEnv); Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(Builder.class); elementsAnnotatedWith.forEach(element -&gt; &#123; if (element.getKind() != ElementKind.CLASS) &#123; System.out.println(&quot;not class&quot;); return; &#125; TypeMirror elementTypeMirror = element.asType(); String builderClassName = element.getSimpleName() + &quot;Builder&quot;; TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(builderClassName) .addModifiers(Modifier.FINAL, Modifier.PUBLIC); MethodSpec.Builder builderMethod = MethodSpec.methodBuilder(&quot;build&quot;) .returns(TypeName.get(element.asType())) .addModifiers(Modifier.PUBLIC) .addStatement(&quot;$T instance = new $T()&quot;, TypeName.get(elementTypeMirror), TypeName.get(elementTypeMirror)); element.getEnclosedElements().forEach(field -&gt; &#123; if (field.getKind() == ElementKind.FIELD) &#123; boolean isStatic = field.getModifiers().contains(STATIC); if (isStatic) &#123; System.out.println(field.getSimpleName() + &quot; is static&quot;); return; &#125; String fieldName = field.getSimpleName().toString(); System.out.println(fieldName); String transformedName = upperFirstChar(fieldName); MethodSpec methodSpec = MethodSpec.methodBuilder(&quot;build&quot; + transformedName) .returns(TypeName.get(element.asType())) .returns(ClassName.get(&quot;com.example&quot;, builderClassName)) .addModifiers(Modifier.PUBLIC) .addParameter(TypeName.get(field.asType()), field.getSimpleName().toString()) .addStatement(&quot;this.$L = $L;return this&quot;, field.getSimpleName().toString() , field.getSimpleName().toString()) .build(); FieldSpec fieldSpec = FieldSpec.builder(TypeName.get(field.asType()), fieldName, Modifier.PRIVATE).build(); String fieldSetName = upperFirstChar(fieldName); builderMethod.addStatement(&quot;instance.set$L(this.$L)&quot;, fieldSetName, fieldName); typeBuilder.addField(fieldSpec); typeBuilder.addMethod(methodSpec); &#125; &#125;); builderMethod.addStatement(&quot;return instance&quot;); typeBuilder.addMethod(builderMethod.build()); TypeSpec typeSpec = typeBuilder.build(); try &#123; JavaFile.builder(&quot;com.example&quot;, typeSpec).build().writeTo(System.out); JavaFile.builder(&quot;com.example&quot;, typeSpec).build().writeTo(filer); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); return true; &#125; private static String upperFirstChar(String name) &#123; if (name.length() &lt; 1) &#123; return name; &#125; String firstChar = name.substring(0, 1).toUpperCase(); if (name.length() &gt; 1) &#123; return firstChar + name.substring(1); &#125; return firstChar; &#125;&#125; 问题一些在测试中遇到但还没有解决的问题： 测试过程中发现在 idea 的配置中 lombok 的注解处理器被自定义的替换掉了，导致无法使用（见 Java 服务注册）; apt jdk 8 注解 代码生成","categories":[],"tags":[]},{"title":"进程管理","slug":"yuque/进程管理","date":"2020-02-21T08:36:33.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/02/21/yuque/进程管理/","link":"","permalink":"http://daiwenzh5.github.io/2020/02/21/yuque/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"查看进程**ps **用于报告当前系统的进程状态。","text":"查看进程**ps **用于报告当前系统的进程状态。 123456789101112131415# 使用 help 查看 ps 所有指令ps [options] [--help]# 常用指令## grep 搜索字符串，匹配进程名## &gt; 进程名 = 路径 + 文件名## &gt; 当匹配非路径时会在所有目录下进行模糊查询## &gt; 当匹配文件的绝对路径时，会精确查找进程## &gt; 当匹配目录时，会查询该目录下所有进程## 查看指定名称的所有进程详细信息ps -aux | grep &lt;string&gt;## 查看指定名称的所有进程信息ps -ef | grep &lt;string&gt; 杀死进程**kill**** **删除执行中的程序或工作。 123456789101112131415161718# 使用 ? 查看 kill 用法kill -?## 用法:kill [-s 信号声明 | -n 信号编号 | -信号声明] 进程号 | 任务声明 ... 或 kill -l [信号声明]## 列出所有信息名称kill -l## 使用第九种信号，通过指定的 pid 强制查杀进程kill -9 &lt;pid&gt;## 其他常用信号HUP 1 终端断线INT 2 中断（同 Ctrl + C）QUIT 3 退出（同 Ctrl + \\）TERM 15 终止KILL 9 强制终止CONT 18 继续（与STOP相反， fg/bg命令）STOP 19 暂停（同 Ctrl + Z） 查杀进程使用 **ps**** 、kill** 组合，可以在查找进程后直接杀死。 123456789101112131415# 强制查杀指定名称的进程## string 指定为目录，进行批量查杀进程（已验证）## awk 的作用是指定输出某一列，awk &#x27;&#123;print $2&#125;&#x27; 输出第二列，即 pidps -ef | grep &lt;string&gt; | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9##kill -9 `ps -ef | grep &lt;string&gt; | grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`## 输出 pid 到文件，然后遍历（未验证）ps -ef | grep &lt;string&gt; | grep -v grep | awk -F&#x27; &#x27; &#x27;&#123;print $2&#125;&#x27; &gt; ./fock_chang.txtwhile read pid; do echo $pid; kill -9 $pid; done &lt; ./fock_chang.txt## 输出 pid 到内存，然后遍历（未验证）for pid in `ps -ef | grep &lt;string&gt; | grep -v grep | awk -F&#x27; &#x27; &#x27;&#123;print $2&#125;&#x27;`;do echo $pid;kill -9 $xx; done","categories":[],"tags":[]},{"title":"自定义 JDK 锁","slug":"yuque/自定义 JDK 锁","date":"2020-02-12T08:54:50.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/02/12/yuque/自定义 JDK 锁/","link":"","permalink":"http://daiwenzh5.github.io/2020/02/12/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%20JDK%20%E9%94%81/","excerpt":"目的从设计者的角度考量如何实现一个较为完整的 JDK 锁（Lock 接口）。预期的效果：","text":"目的从设计者的角度考量如何实现一个较为完整的 JDK 锁（Lock 接口）。预期的效果： 不可重入锁：当线程持有锁后再次尝试获取锁会被阻塞； 可重入锁：线程可重复获取锁，多次持有将其同步状态计数器累计加一，释放则减一，直到计数器为零时，表示锁完全被释放，其他线程可恢复； 公平锁：按照线程进入 lock 的先后顺序，依次获取锁； 独占锁（排他锁）：只有一个线程可以持有锁； 完全实现 Lock 接口：实现该接口所有方法； CAS 机制Compare And Set（Swap），即比较并设置（替换）：对于变量，将预期值 Old 通过内存地址 V 于变量进行比较，当通过校验时，将新值 New 赋值给内存 V。 使用场景 数据库乐观锁更新； 网站访问量； Atomic 原子类； JVM 内部的 Unsafe 类； 限制 只能保证单个变量在多线程下的安全性，对代码块无效； ABA 问题：即仅对结果进行预期控制，无法约束过程，可能在执行过程中发生如： A-&gt;B-&gt;A 这样的状态变化，解决方法是追加版本号； Lock 接口Lock 接口位于 J.U.C（java.util.concurrent）的 locks 包下，区别于 JVM 内置锁（synchronized），该接口通过手动实现 JDK 锁，而能够提供灵活的锁管理机制，如：尝试非阻塞式获取锁、可中断获取锁、可超时获取锁。 不可重入锁 简单的实现了获取锁/释放锁的操作； 通过 CAS 机制，判断当前线程是否持有锁； 需要频繁读写等待队列，此处使用 LinkedBlockingQueue&lt;Thread&gt; 来保证在线程安全的前提下提供更好的性能； 此处使用了 Lock 来修改了线程状态，因此并不是自旋锁。 1234567891011121314151617181920212223@Overridepublic void lock() &#123; // 无限循环直到当前线程持有锁 while (!owner.compareAndSet(null, Thread.currentThread())) &#123; // 将当前线程添加到等待队列 waiter.add(Thread.currentThread()); // 挂起当前线程 LockSupport.park(); // 线程被唤醒后，从等待队列移除当前线程 waiter.remove(Thread.currentThread()); &#125;&#125;@Overridepublic void unlock() &#123; // 当前线程持有锁时执行释放锁 if (owner.compareAndSet(Thread.currentThread(), null)) &#123; // 释放挂起线程 for (Thread thread : waiter) &#123; LockSupport.unpark(thread); &#125; &#125;&#125; 测试 在 number 自增时添加锁； 创建 5 个线程，每个线程遍历 1000 次，对 number = 0，进行自增，预期结果为 5000； 在线程切换时，需要添加休眠时间，否则程序执行过快，无法看到预期效果； 123456789101112131415161718192021222324252627private Lock simpleLock = new SimpleLock();private void increment() &#123; simpleLock.lock(); try &#123; number++; &#125; finally &#123; simpleLock.unlock(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; SimpleLockTest simpleLockTest = new SimpleLockTest(); int threadNumber = 5; int max = 1000; for (int i = 0; i &lt; threadNumber; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; max; j++) &#123; // Files.readAllLines(Paths.get(&quot;C:\\\\Users\\\\daiwenzh5\\\\Downloads\\\\激活码 (3).txt&quot;)); simpleLockTest.increment(); simpleLockTest.doubleLock(); &#125; &#125;).start(); &#125; Thread.sleep(100); System.out.printf(&quot;simpleLockTest.number = %d&quot;, simpleLockTest.number);&#125; 结果123simpleLockTest.number &#x3D; 5000Process finished with exit code 0 自旋锁 当线程未能获取锁时，让线程不停的执行循环体，而不修改线程状态，通过循环来阻塞无锁线程，称之为自旋锁； 但是由于每个线程都需要执行循环，当线程数不停增加时，性能下降明显，所以自旋锁仅适用于线程竞争不激烈（线程数量少），持有锁的时间短（频繁切换线程）的场景； 可重入锁在普通的不可重入锁的基础上，为线程获取锁的状态添加一个计数器，一旦线程持有锁则计数器自增，在锁未被释放之前，只有持有锁的线程可以再次获取锁，使得计数器不断增加。在线程释放锁时，每一次都使得计数器自减，直到其值为 0 时，表示线程完全释放了锁，此时将锁持有者线程置空即可。 使用场景 当同步方法嵌套使用时，需要使用可重入锁，用以避免死锁问题； 代码分析 无锁的线程通过循环遍历进行挂起； 线程一旦持有锁，则退出循环，并将其同步计数器自增； 123456789101112131415161718192021222324252627282930313233@Overridepublic void lock() &#123; // 判断当前线程是否持有锁，若没有则尝试获取锁，获取成功则推出循环 while (!(owner.get() == Thread.currentThread() || owner.compareAndSet(null, Thread.currentThread()))) &#123; waiter.add(Thread.currentThread()); LockSupport.park(); waiter.remove(Thread.currentThread()); &#125; // 同步状态计数器自增 count.incrementAndGet();&#125;private void print() &#123; System.out.printf(&quot;ownerThread:%s,currentThread:%s%n&quot;, owner.get() == null ? &quot;null&quot; : owner.get().getName(), Thread.currentThread().getName());&#125;@Overridepublic void unlock() &#123; // 判断当前线程是否持有锁 if (owner.get() == Thread.currentThread()) &#123; // 对同步状态计数器每次自减后判断其值是否为 0 // 0 表示锁被释放 if (count.decrementAndGet() == 0) &#123; owner.set(null); for (Thread thread : waiter) &#123; LockSupport.unpark(thread); &#125; &#125; &#125;&#125; 测试在测试代码内部添加两重嵌套的同步方法。 123456789101112private int count = 0;private void doubleLock() &#123; simpleLock.lock(); try &#123; count ++; // number ++ 自增的同步方法 increment(); &#125; finally &#123; simpleLock.unlock(); &#125;&#125; 结果程序成功执行并退出，且结果符合预期，两重同步锁嵌套未发生死锁。 123simpleLockTest.number = 5000, count = 5000Process finished with exit code 0 公平锁 按照进入 lock 的先后顺序（即等待队列），依次给线程获取锁； 注意事项","categories":[],"tags":[]},{"title":"自定义类加载器","slug":"yuque/自定义类加载器","date":"2020-02-06T08:18:45.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/02/06/yuque/自定义类加载器/","link":"","permalink":"http://daiwenzh5.github.io/2020/02/06/yuque/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"目的为什么需要自定义类加载器，其需求是什么？或者说其应用场景是什么？","text":"目的为什么需要自定义类加载器，其需求是什么？或者说其应用场景是什么？ 安全性：Java 代码能够被轻易的反编译，在足够优秀的 IDE 面前，class 文件等价于 java 文件，为了保证代码的安全性，可以将编译后的代码使用约定好的算法进行加密，这样的 class 文件时无法使用 Java 自有的类加载器读取的，此时就需要通过自定义加载器，在读取类时先解密后加载； 资源隔离：对于同一 jvm 来说，不同类加载器实例化的同名类对象，实际上是不相等，每一个类加载器都相当于一个独立的容器； 解决 jar 包冲突：基于上一点，同一个类名可以同时存在每一个类加载器中； 读取加密 class 文件原理自定义类加载器需要继承 ClassLoader 或其增强类 URLClassLoader，其中存在 findClass 方法，用于读取 class 文件，并通过搜索类的限定名对其进行加载，最终返回一个 Class 对象。因此在读取 class 文件时，可以对其二进制字节进行解密，将其还原成原始的 class 文件，然后挂载到 jvm 中。 局限通常情况下，只会使用 java 代码来实现自定义类加载器，不能加载其自身，即类加载器是可以作为反编译的切入点；同时，jvm 加载的类字节存在内存中，也是可以被访问的，狠一点的方法是通过其他语言来实现类加载器，但也不能完全避免反编译。 注意事项 单例模式：自定义类加载器在使用时，会加载指定类，每次实例化类加载器，每个对象之间同样是资源隔离的，因此，频繁调用会使得 jvm 中挂载的类越来越多，最终导致内存溢出，因此需要将自定义类加载器设计成单例模式，spring 项目中，注册成 bean 即可被 spring 托管； 代码实现类加载器 继承自 URLClassLoader，特点是可以指定外部 jar 或 class 文件； 主要重写 findClass 方法，用于读取 class 文件二级制字节并加载类； 需要在读取字节后对其解密； 123456789101112131415161718192021222324252627282930313233public class SimpleClassLoader extends URLClassLoader &#123; public SimpleClassLoader(URL... urls) &#123; super(urls); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; for (URL url: this.getURLs()) &#123; byte[] bytes = decrypt(url) ; // 将二进制字节转换成 java.lang.Class return this.defineClass(name, bytes, 0, bytes.length); &#125; return super.findClass(name); &#125; private byte[] decrypt(URL url) &#123; try &#123; return SimpleEncryptUtils.decrypt(url.openStream()); &#125; catch (IOException e) &#123; System.out.println(&quot;【类文件解码】jar 或 class 不存在&quot;); return null; &#125; &#125; public static void main(String[] args) &#123; testPeople(); &#125; private static void testPeople() &#123;// String target = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-origin.class&quot;; String target = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-encrypt-1581006788342.class&quot;; test(target, &quot;com.example.demo.bean.People&quot;); &#125;&#125; 异或加密 特点是简单，便于测试; 核心方法是 byte[] encrypt(byte[] bytes, String key)，其他方法都是基于此方法的重载，便于使用； main 方法中对 People.class 文件使用异或加密，并导出得到加密后的文件； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class SimpleEncryptUtils &#123; public static final String DEFAULT_KEY = &quot;daiwenzh5♪(＾∀＾●)ﾉ&quot;; public static byte[] encrypt(byte[] bytes, String key) &#123; byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8); for (int i = 0; i &lt; bytes.length; i++) &#123; for (byte keyByte : keyBytes) &#123; bytes[i] = (byte) (bytes[i] ^ keyByte); &#125; &#125; return bytes; &#125; public static byte[] encrypt(byte[] bytes) &#123; return encrypt(bytes, DEFAULT_KEY); &#125; public static byte[] encrypt(InputStream inputStream) &#123; return encrypt(inputStream, DEFAULT_KEY); &#125; public static byte[] encrypt(InputStream inputStream, String key) &#123; try &#123; BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); byte[] bytes = new byte[bufferedInputStream.available()]; bufferedInputStream.read(bytes); return encrypt(bytes, key); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; return new byte[0]; &#125; public static byte[] decrypt(byte[] bytes, String key) &#123; // 因为是取反，所以解密过程和加密过程一致 return encrypt(bytes, key); &#125; public static byte[] decrypt(byte[] bytes) &#123; // 因为是取反，所以解密过程和加密过程一致 return decrypt(bytes, DEFAULT_KEY); &#125; public static byte[] decrypt(InputStream inputStream) &#123; // 因为是取反，所以解密过程和加密过程一致 return decrypt(inputStream, DEFAULT_KEY); &#125; public static byte[] decrypt(InputStream inputStream, String key) &#123; // 因为是取反，所以解密过程和加密过程一致 return encrypt(inputStream, key); &#125; public static void encryptFile(String src, String dist) &#123; try &#123; Path path = Paths.get(dist); if (!Files.exists(path)) &#123; Files.createFile(path); &#125; Files.write(path, Objects.requireNonNull(encrypt(Files.newInputStream(Paths.get(src))))); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void decryptFile(String src, String dist) &#123; encryptFile(src, dist); &#125; private static void testDecryptFile() &#123; long time = System.currentTimeMillis(); // 加密文件// String src = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-origin.class&quot;; String src = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-encrypt-1581006788342.class&quot;; // 解密路径 String dist = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-decrypt-&quot; + time + &quot;.class&quot;; System.out.printf(&quot;文件名：People-decrypt-%d.class%n&quot;, time); decryptFile(src, dist); &#125; private static void testEncryptFile() &#123; long time = System.currentTimeMillis(); // 源文件 String src = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-origin.class&quot;; // 加密路径 String dist = &quot;C:\\\\Users\\\\daiwenzh5\\\\Desktop\\\\test\\\\People-encrypt-&quot; + time + &quot;.class&quot;; System.out.printf(&quot;文件名：People-encrypt-%d.class%n&quot;, time); encryptFile(src, dist); &#125; private static void testString(String content) &#123; byte[] encrypt = encrypt(content.getBytes(StandardCharsets.UTF_8)); System.out.println(new String(encrypt, StandardCharsets.UTF_8)); System.out.println(new String(decrypt(encrypt), StandardCharsets.UTF_8)); &#125; public static void main(String[] args) &#123;// testString(&quot;hello world&quot;); testEncryptFile();// testDecryptFile(); &#125;&#125; class 文件 People-origin.class（原始文件） People-encrypt-1581006788342.class（加密文件） 执行结果 加密 class 文件被成功读取，并通过反射正确输出对象类名； 如期地打印其使用的类加载器； 12Peoplecom.example.demo.configs.SimpleClassLoader@1218025c","categories":[],"tags":[]},{"title":"Spring Aop 插件式开发","slug":"yuque/Spring Aop 插件式开发","date":"2020-02-05T10:39:56.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/02/05/yuque/Spring Aop 插件式开发/","link":"","permalink":"http://daiwenzh5.github.io/2020/02/05/yuque/Spring%20Aop%20%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91/","excerpt":"目的spring aop 能够对其托管的 bean 进行无侵入式的增强，原有代码与增强代码之间解耦，但是其配置始终是写死在项目中，对其管理依旧需要重启项目，这对生产来说是比较麻烦的。插件式开发正是解决此类问题的一种有效方案，能够提供灵活的、可插拔式的热更新（即无重启更新），通过定义合适的配置文件，能够提供方便有效且统一的管理页面。同时，也可基于环境读取不同的配置，实现同一插件在不同环境的个性化配置。对于插件来说，只要向运行项目提供透明的配置信息，则可以在项目外直接被识别并使用。","text":"目的spring aop 能够对其托管的 bean 进行无侵入式的增强，原有代码与增强代码之间解耦，但是其配置始终是写死在项目中，对其管理依旧需要重启项目，这对生产来说是比较麻烦的。插件式开发正是解决此类问题的一种有效方案，能够提供灵活的、可插拔式的热更新（即无重启更新），通过定义合适的配置文件，能够提供方便有效且统一的管理页面。同时，也可基于环境读取不同的配置，实现同一插件在不同环境的个性化配置。对于插件来说，只要向运行项目提供透明的配置信息，则可以在项目外直接被识别并使用。 实现原理JVM 通过类加载器在启动时加载 class 文件，且一般地只会加载一次，但在程序内可以通过手动配置类加载器，可提供要加载的类的 jar 包路径及限定名，将其读取并加载到虚拟机，之后通过反射可以实例化加载的类对象，最后注册成 spring bean 之后就可以被 spring 托管。 代码实现插件的基本配置123456789&#123; &quot;config&quot;: &#123; &quot;active&quot;: false, &quot;className&quot;: &quot;com.example.plugin.libs.LogPlugin&quot;, &quot;id&quot;: 1, &quot;jarRemoteUrl&quot;: &quot;C:WorkspaceVSCodeProjectsJavademosrcmain\\resourcesplugins&quot;, &quot;name&quot;: &quot;日志插件&quot; &#125;&#125; 属性 备注 id 唯一标识 name 插件名称 jarRemoteUrl jar 包的地址 className 类的限定名 active 是否激活 注：以上为必备属性，亦可添加描述、版本号等其他属性。 类加载器读取插件URLClassLoader 类加载器可以通过路径来读取 jar 包，但由于其 addURL 方法并不是被 public 修饰，无法直接访问，因此需要通过反射来获取该方法的使用权限。同时应该避免多次加载重复文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 加载插件 * * @param plugin 插件 * @return 返回 aop 通知对象 */public Advice load(PluginConfig plugin) &#123; // 若缓存中已存在该类，则直接返回 if (adviceCache.containsKey(plugin.getClassName())) &#123; System.out.println(&quot;【加载插件】读取缓存成功&quot;); return adviceCache.get(plugin.getClassName()); &#125; System.out.println(&quot;【加载插件】正在读取插件配置...&quot;); // 获取插件 jar 包路径 try &#123; URL targetUrl = Paths.get(plugin.getJarRemoteUrl()).toUri().toURL(); // 获取当前项目的类加载器 URLClassLoader loader = (URLClassLoader) this.getClass().getClassLoader(); boolean isLoader = false; // 遍历已加载类 for (URL url : loader.getURLs()) &#123; // 当前插件已经被加载退出 if (url.equals(targetUrl)) &#123; System.out.println(&quot;【加载插件】插件已被加载！&quot;); isLoader = true; break; &#125; &#125; // 当该插件尚未被加载 if (!isLoader) &#123; // 反射获取类加载器的 addURL 方法 if (addURLMethod == null) &#123; System.out.println(&quot;【加载插件】初次调用，获取类加载器的 addURL 方法&quot;); addURLMethod = URLClassLoader.class.getDeclaredMethod(&quot;addURL&quot;, URL.class); if (!addURLMethod.isAccessible()) &#123; addURLMethod.setAccessible(true); &#125; &#125; System.out.println(&quot;【加载插件】正在加载插件：&quot; + targetUrl); // 类加载器获取将插件的 jar 路径 addURLMethod.invoke(loader, targetUrl); &#125; // 加载类 Class&lt;?&gt; adviceClass = Class.forName(plugin.getClassName()); // 创建插件对象，并缓存 System.out.println(&quot;【加载插件】生成插件并缓存&quot;); adviceCache.put(adviceClass.getName(), (Advice) adviceClass.newInstance()); &#125; catch (MalformedURLException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | ClassNotFoundException | InstantiationException e) &#123; System.out.println(e.getLocalizedMessage()); &#125; return adviceCache.get(plugin.getClassName());&#125; 注册成 spring bean此处的插件基于 aop。对于 aop 增强的 bean 会被 spring 自动在最顶层上生成一个 Advised 的增强类，因此插件的最终去向是被应用在 bean instanceof Advised （即被增强的）spring 类对象上，当然，插件实现是应该继承 spring aop 的通知接口，如 MethodBeforeAdvice 等。 1234567891011121314151617181920212223242526272829303132333435@Datapublic class LogPlugin implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] args, Object target) &#123; System.out.println( method.getDeclaringClass().getName() + &quot;.&quot; + method.getName() + &quot;,args = &quot; + Arrays.toString(args)); &#125;&#125;//////////// 激活插件/** * 激活插件 * @param id 插件 id */public void active(String id) &#123; PluginConfig pluginConfig = pluginConfigMap.get(id); System.out.println(&quot;【插件激活】正在激活插件：&quot; + pluginConfig); // 检查插件是否被加载 if (!pluginConfigMap.containsKey(id)) &#123; throw new RuntimeException(&quot;【插件激活】尚未读取插件配置信息，无法激活&quot;); &#125; Object bean; for (String name : applicationContext.getBeanDefinitionNames()) &#123; bean = applicationContext.getBean(name); if (bean == this || !(bean instanceof Advised) || findAdvice((Advised) bean, pluginConfig.getClassName())) &#123; continue; &#125; System.out.printf(&quot;【插件激活】正在为【%s】激活插件&quot;, name); // 对增强 bean 应用插件 ((Advised) bean).addAdvice(this.load(pluginConfig)); &#125; System.out.println(&quot;【插件激活】激活完毕&quot;);&#125; 注意事项 使用 spring-boot-maven-plugin 打包会同时生成两个 jar 包，一种是可直接执行的程序包（.jar），另一种是作为外部引用的依赖包（.jar.original）。这里需要的是依赖包，使用压缩软件打开可以看到，其目录结构完全符合类的限定名（jar/包名/类名）；而可执行程序的目录是（jar/BOOT-INF/classes/包名/类名）； 对于类加载器，可以使用当前类的加载器 (URLClassLoader) this.getClass().getClassLoader()，也可以使用系统类加载器 (URLClassLoader) ClassLoader.getSystemClassLoader()，但都需要转型为 URLClassLoader，因为其可以加载外部 jar 或 class 文件； spring aop 接口对 bean 的要求是其顶层实现必须继承 Advised 接口，因此，对于需要支持插件增强的 bean 必须已经被 aop 切入，所以最好的做法是提前使用一个空白的切面组件对 bean 进行标记，如： 1234567@Aspect@Componentpublic class PluginAspect &#123; @After(value = &quot;execution(* com.example.demo.controller..*.*(..))&quot;) public void after() &#123;&#125;&#125; 实际上，切面方法内不执行任何操作，目的是将 com.example.demo.controller 包下的所有方法都连接上切 面； 使用场景包括但不限于以下几种： 日志； 性能监控； 权限拦截器； 待测试 自动加载插件：通过监听插件所在目录变化，自动读取插件配置并加载插件； 自动生成插件配置：统一插件的生成方式，能够在打包时自动的生成插件的配置信息；","categories":[],"tags":[]},{"title":"Git 配置多账户","slug":"yuque/Git 配置多账户","date":"2020-01-19T16:50:50.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/01/20/yuque/Git 配置多账户/","link":"","permalink":"http://daiwenzh5.github.io/2020/01/20/yuque/Git%20%E9%85%8D%E7%BD%AE%E5%A4%9A%E8%B4%A6%E6%88%B7/","excerpt":"需求描述需要为不同的 git （如：github、gitlab、gitee）配置 ssh，因为 ssh 内置了账户（邮箱），所以一旦这些 git 的账户名不同，自然得为其配置不同的 ssh 文件。","text":"需求描述需要为不同的 git （如：github、gitlab、gitee）配置 ssh，因为 ssh 内置了账户（邮箱），所以一旦这些 git 的账户名不同，自然得为其配置不同的 ssh 文件。 方法 打开 shell，进入 C:\\Users\\%username%\\.ssh 目录； 输入：ssh-keygen -t rsa -C &#39;zhudaiwen@git.51baiwang.com&#39; -f ./gitlab_bw/id_rsa，生成密钥并指定其存放在 .ssh/gitlab_bw（目录名意为公司自建的 gitlab 服务器，此处随意，或任意不同的文件名即可）; 在 .ssh 目录下，新建 config 文件，在其内指定 git 服务器对应的域名（主机名或 IP）， 12345# gitlab_bwHost git.51baiwang.comHostName git.51baiwang.comPreferredAuthentications publickeyIdentityFile &quot;C:\\Users\\daiwenzh5\\.ssh\\gitlab_bw\\id_rsa&quot; 为其他不同的 git 账户重复上述步骤（需要注意步骤 2 时，须命名不同或存放不同目录）。","categories":[],"tags":[]},{"title":"PageHelper 分页结果类型转换","slug":"yuque/PageHelper 分页结果类型转换","date":"2020-01-05T07:42:49.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/01/05/yuque/PageHelper 分页结果类型转换/","link":"","permalink":"http://daiwenzh5.github.io/2020/01/05/yuque/PageHelper%20%E5%88%86%E9%A1%B5%E7%BB%93%E6%9E%9C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"问题描述在 Mybatis 中使用 PageHelper 插件可以轻易的实现分页查询，但是对于某些时候，从库中直接返回的 Po 对象并不是最终需要返回的类型，即分页中的结果集需要进行类型转换，当然，转换过程中不能丢失分页信息。","text":"问题描述在 Mybatis 中使用 PageHelper 插件可以轻易的实现分页查询，但是对于某些时候，从库中直接返回的 Po 对象并不是最终需要返回的类型，即分页中的结果集需要进行类型转换，当然，转换过程中不能丢失分页信息。 分析通过观察 PageHelper 插件的源码可以知道，其分页结果为 Page 对象，继承了 ArrayList 对象，其结果集通过泛型来约束类型。而实际上，java 中的泛型类型约束偏向于编译器层面，即由编译器对泛型进行类型检查，一旦编译通过，最终会转换为原始类型，称之为类型（泛型）擦除，正是有这样的机制存在，此处可以较为简单的实现对分页结果的类型转换。 解决方案思路 启动分页器，执行查询 sql 执行分页，设定结果集类型未 T； 提取分页结果并进行类型转换，设转换类型为 E，保存结果为 result（List&lt;E&gt;） 变量； 对分页对象 Page&lt;T&gt; 执行其继承自父类的 ArrayList#clear() 方法，清除原结果集； 对 Page&lt;T&gt; 对象进行显示的强转，转换结果类型与 result（E） 变量保持一致，此处会出现编译器警告，但实际上由于类型擦除的机制存在，在编译后的类型始终是原始类型 Page，（且已经提前清空了强转之前的泛型类型对象）因此此处忽略警告对编译结果不会造成异常影响； 最后将转换的结果 result 置入强转后的 Page&lt;E&gt; 对象中。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class PageHelpers&lt;K, E&gt; &#123; private Page&lt;E&gt; page; /** * 开始分页 * * @param pageNum 页码 * @param pageSize 每页显示数量 * @param execute 查询 sql * @param mapper 结果集转换方法 * @return 返回 &#123;@code PageHelpers&#125; */ @SuppressWarnings(&quot;unchecked&quot;) public PageHelpers&lt;K, E&gt; startPage(int pageNum, int pageSize, Supplier&lt;?&gt; execute, Function&lt;? super K, ? extends E&gt; mapper ) &#123; Page&lt;K&gt; origin = PageHelper.startPage(pageNum, pageSize); // 必须使用函数参数，来保住查询 sql 是紧跟分页器之后执行 // 否则，分页器无法捕捉查询结果集 execute.get(); // 转换结果集类型 List&lt;E&gt; result = origin.getResult().stream().map(mapper).collect(Collectors.toList()); origin.clear(); // 泛型仅作编译时类型约束，编译后统一转换为最小继承的类型， // 此处未限定，即转换为 Object，因此当确保使用时类型正确，是可以进行强转的 page = (Page&lt;E&gt;) origin; page.addAll(result); return this; &#125; /** * 获取分页信息 * * @return &#123;@code PageInfo&#125; */ public PageInfo&lt;E&gt; getPageInfo() &#123; return get().toPageInfo(); &#125; /** * 返回分页对象 * * @return &#123;@code Page&#125; */ public Page&lt;E&gt; get() &#123; return page; &#125; 其他当然，使用 BeanUtils#copyProperties() 复制对象的属性，或者使用反射提取其字段，都是可以实现对分页结果的类型转换。","categories":[],"tags":[]},{"title":"Spring 注入 bean 失败","slug":"yuque/Spring 注入 bean 失败","date":"2020-01-03T07:42:54.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2020/01/03/yuque/Spring 注入 bean 失败/","link":"","permalink":"http://daiwenzh5.github.io/2020/01/03/yuque/Spring%20%E6%B3%A8%E5%85%A5%20bean%20%E5%A4%B1%E8%B4%A5/","excerpt":"问题描述项目启动时报错，提示无法注入 bean，需要设置在 @EnableAsync 或 @EnableCaching 上配置属性 proxyTargetClass=true 强行使用 CGLib 代理。","text":"问题描述项目启动时报错，提示无法注入 bean，需要设置在 @EnableAsync 或 @EnableCaching 上配置属性 proxyTargetClass=true 强行使用 CGLib 代理。 123456789101112131415***************************APPLICATION FAILED TO START***************************Description:The bean &#39;invoiceMapper&#39; could not be injected as a &#39;com.xxx.yyyMapper&#39; because it is a JDK dynamic proxy that implements:Action:Consider injecting the bean as one of its interfaces or forcing the use of CGLib-based proxies by setting proxyTargetClass&#x3D;true on @EnableAsync and&#x2F;or @EnableCaching.Process finished with exit code 1 原因分析这是在注入 bean invoiceMapper 时使用了 @Resource 而不是 spring 的 @Autowired，前者通过名称来匹配对象，先根据注入 bean 的变量名来查找，找不到则根据类名查找，若遇到同名对象但类型不一致时，就会出现注入失败的问题。 解决方案在注入变量时，将变量名写作类名小写形式的变量，尽量完整，若仍然有同名现象，可重新指定 bean 的名称。 12@Resourceprivate AbcxxxopqService abcxxxopqService;","categories":[],"tags":[]},{"title":"Springboot 整合 Mybatis","slug":"yuque/Springboot 整合 Mybatis","date":"2019-12-29T09:55:20.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/29/yuque/Springboot 整合 Mybatis/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/29/yuque/Springboot%20%E6%95%B4%E5%90%88%20Mybatis/","excerpt":"注解@MapperScan","text":"注解@MapperScanSpringboot 的依赖注入需要通过 @ComponentScan 来扫描所配置的 bean，但是该组件会忽略抽象类和接口，因此 Mybatis 的 mapper 接口就需要使用其专门为 Springboot 依赖注入提供的 @MapperScan 扫描器。通常配置扫描基础包（可以设多个）。 1@MapperScan(basePackages = &quot;com.example.dao.mapper&quot;) 若不配置，则会出现 bean 注入失败的问题。 12org.springframework.beans.factory.UnsatisfiedDependencyExceptionCaused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.example.dao.mapper.xxxMapper&#39; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required&#x3D;true), @org.springframework.beans.factory.annotation.Qualifier(value&#x3D;personMapper)&#125;","categories":[],"tags":[]},{"title":"Idea 启动报错：命令行太长","slug":"yuque/Idea 启动报错：命令行太长","date":"2019-12-27T12:32:01.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/27/yuque/Idea 启动报错：命令行太长/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/27/yuque/Idea%20%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%AA%E9%95%BF/","excerpt":"运行环境Idea：2019.03Spring boot：1.5.6.Release","text":"运行环境Idea：2019.03Spring boot：1.5.6.Release 问题描述这是从 Git 上拉取的新项目，为修改任何配置，但启动时报错，Idea 提示如： 具体报错信息如下： 12Error running &#39;StartupApplication&#39;:Command line is too long. Shorten command line for StartupApplication. 原因分析当启动类的路径太长，或者有很多参数，使得启动时的命令行长度过长，就会使得程序无法启动，这是大多数操作系统都有的限制。 解决方案Idea 有以下几种方式来尝试缩短类路径： none：默认选项，Idea 不进行处理，命令行超出长度限制之后会提示用户配置缩短器； JAR manifest：Idea 通过临时的 classpath.jar 传递长的类路径。原始类路径在 MANIFEST.MF 中定义为 classpath.jar 中的类路径属性。 修改启动配置，选择 【JAR manifest】即可。","categories":[],"tags":[]},{"title":"打包失败：找不到符号","slug":"yuque/打包失败：找不到符号","date":"2019-12-26T14:56:56.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/26/yuque/打包失败：找不到符号/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/26/yuque/%E6%89%93%E5%8C%85%E5%A4%B1%E8%B4%A5%EF%BC%9A%E6%89%BE%E4%B8%8D%E5%88%B0%E7%AC%A6%E5%8F%B7/","excerpt":"问题描述在使用 maven 打包时报错，提示：java: 找不到符号 和 java: 程序包 xxx 不存在。而实际上，错误提示中的依赖包已正确添加，清楚缓存、重新导入等方法均已尝试且无效。","text":"问题描述在使用 maven 打包时报错，提示：java: 找不到符号 和 java: 程序包 xxx 不存在。而实际上，错误提示中的依赖包已正确添加，清楚缓存、重新导入等方法均已尝试且无效。 分析与解决1. 子项目被依赖但后编译分析聚合项目中的子项目之间存在依赖，（假设 A 依赖 B）但是被依赖项 B 在父项目中的位置排在 A 后面，导致编译时先打包 A，而使得 A 无法加载 B 的依赖。 解决调整各个模块在父项目（pom 添加 module）中的位置，将最底层的放置在最上面。 2. 编译插件为生成可依赖包分析在多模块项目打包时父模块的 pom.xml 文件中配置了 spring-boot-maven-plugin 插件。该插件会将 Spring 项目打包成可运行的 jar 或 war 程序，而可运行程序无法被用作依赖，因此出现找不到符号或程序包不存在问题。 解决1. 取消在 pom.xml 中的配置直接去除掉父模块的 pom.xml 中配置的 spring-boot-maven-plugin 插件，使用 Idea 中 maven 插件即可进行打包。缺点是无法在 pom.xml 中统一打包配置。 2. 修改插件配置在插件中指定配置 &lt;classifier&gt;exec&lt;/classifier&gt;，如此可以同时生成可依赖包和可执行程序。 1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt;&lt;/plugin&gt; 3. 更换插件不使用 spring-boot-maven-plugin，替换为 maven-compiler-plugin 插件。 12345&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt;&lt;/plugin&gt;","categories":[],"tags":[]},{"title":"Spring boot maven plugin 使用说明","slug":"yuque/Spring boot maven plugin 使用说明","date":"2019-12-26T12:11:59.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/26/yuque/Spring boot maven plugin 使用说明/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/26/yuque/Spring%20boot%20maven%20plugin%20%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"环境说明maven：v3.2+spring-boot-maven-plugin：2.1.9Idea：2019.03","text":"环境说明maven：v3.2+spring-boot-maven-plugin：2.1.9Idea：2019.03 插件介绍spring-boot-maven-plugin 插件用于提供 spring boot 在 maven 中的支持。运行用户将项目打包成独立的可执行程序。该插件中已经集成了丰富的 org.apache.maven 依赖与插件，具体可通过打开 pom 进行查看。提供了以下（指 maven 构建）目标： run：运行 spring boot 应用； repackage：创建一个可执行的程序； start &amp; stop：在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理； build-info：生成 Actuator 使用的构建信息文件 build-info.properties； 目标：repackage一、可选配置：指定启动类在不指定启动类的情况下，该插件会默认启动第一个找到的 public static void main(String[] args) 方法，当出现以下报错，表示找到不到启动类。 1Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.1.9.RELEASE:repackage (repackage) on project interface: Execution repackage of goal org.springframework.boot:spring-boot-maven-plugin:2.1.9.RELEASE:repackage failed: Unable to find main class 1. 非继承 spring-boot-starter-parent 的 pom在插件的 configuration 属性中，通过 mainClass 指定启动类。 1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; 2. 继承 spring-boot-starter-parent 的 pom在 pom 配置 start-class 属性即可。 123&lt;properties&gt; &lt;start-class&gt;com.example.startup.Application1&lt;/start-class&gt;&lt;/properties&gt; 这是因为在 spring-boot-starter-parent 中，已经对其进行了默认配置。 123456789101112131415&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;mainClass&gt;$&#123;start-class&#125;&lt;/mainClass&gt; &lt;/configuration&gt;&lt;/plugin&gt; 二、可选配置：依赖排除用于剔除不需要打包的依赖。 12345678910111213141516171819202122&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 根据 groupId 以及 artifactId 排除依赖 --&gt; &lt;excludeGroupIds&gt;$&#123;groupId&#125;&lt;/excludeGroupIds&gt; &lt;excludes&gt; &lt;!-- 根据 groupId 以及 artifactId 排除依赖 --&gt; &lt;exclude&gt; &lt;groupId&gt;$&#123;groupId&#125;&lt;/groupId&gt; &lt;artifactId&gt;$&#123;artifactId&#125;&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 三、可选配置：分离器默认情况下，repackage 构建目标会将打包好的项目再次打包变成可直执行程序，但是这样若是在多模块项目中，模块之间互相依赖，就需要使用分离器（classifier 属性），将依赖的内容和可执行程序分离，这样可以在打包时分别生成可依赖包和可执行程序。 1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt;&lt;/plugin&gt; 多模块打包问题 如果不配置分离器，会在打包时提示：“找不到符号”或“应用程序不存在”； 若插件配置在父模块中，则对于所有模块都会进行分离，而对于 spring 项目，可执行程序只需要包含启动类（如：startup 模块）即可，所以为了避免生成多余的可执行文件，可以只在 startup 模块中配置。 其他配置一、自定义打包名称直接使用 maven 的标准属性 fileName，即可。如： 123&lt;build&gt; &lt;finalName&gt;程序名称&lt;/finalName&gt;&lt;/build&gt; 二、跳过单元测试1. 配置属性maven 默认在打包时会进行单元测试（这与 spring boot 无关），若要跳过，则需要在 pom 中配置 skipTests 属性，或 maven.test.skip 属性。区别是前者不进行测试但会编译，而后者直接忽略编译。 123456&lt;properties&gt; &lt;!-- 编译但不允许 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;!-- 跳过编译 --&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;&lt;/properties&gt; 这是由于 spring-boot-maven-plugin 内集成了 maven-surefire-plugin 插件，该插件专门用来处理 maven 中的单元测试。 2. 使用 Idea Maven 插件选中 Idea 的 Maven 插件（通常处于有侧边栏）上的蓝色 ⚡ 按钮，即可跳过测试模块。 3. 自定义 Maven 命令 打包结果若配置了分离器，则会生成两个 jar 包文件： 可执行 jar 包：*.jar； 可依赖 jar 包：*.original.jar","categories":[],"tags":[]},{"title":"Notepad ++ 配置 nginx.conf 语法高亮","slug":"yuque/Notepad ++ 配置 nginx.conf 语法高亮","date":"2019-12-25T12:12:13.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/25/yuque/Notepad ++ 配置 nginx.conf 语法高亮/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/25/yuque/Notepad%20++%20%E9%85%8D%E7%BD%AE%20nginx.conf%20%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/","excerpt":"环境说明版本：notepad++V7.8.2(64-bit)。语言：中文。","text":"环境说明版本：notepad++V7.8.2(64-bit)。语言：中文。 配置步骤 在导航栏选择【语言】-【User Defined Language】-【Open User Defined Language folder…】，最终会打开一个用于放置用于自定义语言配置的文件夹； 下载 userDefineLang_nginx.xml，将其添加到上步打开的文件夹； 重新在导航选择【语言】-【Nginx】。 配置文件为了防止连接挂掉或者 git 访问不了，下面贴出了具体的配置文件。该文件内容完全获取自互联网。 123456789101112131415161718192021222324252627282930313233343536&lt;NotepadPlus&gt; &lt;UserLang name=&quot;Nginx&quot; ext=&quot;conf&quot;&gt; &lt;Settings&gt; &lt;Global caseIgnored=&quot;yes&quot; escapeChar=&quot;\\&quot; /&gt; &lt;TreatAsSymbol comment=&quot;no&quot; commentLine=&quot;yes&quot; /&gt; &lt;Prefix words1=&quot;yes&quot; words2=&quot;yes&quot; words3=&quot;no&quot; words4=&quot;no&quot; /&gt; &lt;/Settings&gt; &lt;KeywordLists&gt; &lt;Keywords name=&quot;Delimiters&quot;&gt;000000&lt;/Keywords&gt; &lt;Keywords name=&quot;Folder+&quot;&gt;&#123;&lt;/Keywords&gt; &lt;Keywords name=&quot;Folder-&quot;&gt;&#125;&lt;/Keywords&gt; &lt;Keywords name=&quot;Operators&quot;&gt;&#x27; &quot; * ; [ ] ^ ~ =&lt;/Keywords&gt; &lt;Keywords name=&quot;Comment&quot;&gt;1 1 2 2 0#&lt;/Keywords&gt; &lt;Keywords name=&quot;Words1&quot;&gt;$ CONTENT_ DOCUMENT_ GATEWAY_ HTTP_ HTTPS if_not_empty PATH_ QUERY_ REDIRECT_ REMOTE_ REQUEST_ SCGI SCRIPT_ SERVER_&lt;/Keywords&gt; &lt;Keywords name=&quot;Words2&quot;&gt;@&lt;/Keywords&gt; &lt;Keywords name=&quot;Words3&quot;&gt;http server events location include&lt;/Keywords&gt; &lt;Keywords name=&quot;Words4&quot;&gt;accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime break charset charset_map charset_types chunked_transfer_encoding client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type deny devpoll_changes devpoll_events directio directio_alignment disable_symlinks empty_gif env epoll_events error_log error_page expires fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_bypass fastcgi_cache_key fastcgi_cache_lock fastcgi_cache_lock_timeout fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_purge fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_keep_conn fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_no_cache fastcgi_param fastcgi_pass fastcgi_pass_header fastcgi_read_timeout fastcgi_redirect_errors fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path flv geo geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_http_version gzip_min_length gzip_proxied gzip_static gzip_types gzip_vary if if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_sharpen image_filter_transparency imap_capabilities imap_client_buffer include index internal ip_hash keepalive keepalive_disable keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_conn_zone limit_except limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_close lingering_time lingering_timeout listen location lock_file log_format log_format_combined log_not_found log_subrequest map map_hash_bucket_size map_hash_max_size master_process max_ranges memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_pass memcached_read_timeout memcached_send_timeout merge_slashes min_delete_depth modern_browser modern_browser_value mp4 mp4_buffer_size mp4_max_buffer_size msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_min_uses open_file_cache_valid open_log_file_cache optimize_server_names override_charset pcre_jit perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect post_action postpone_output protocol proxy proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_bypass proxy_cache_key proxy_cache_lock proxy_cache_lock_timeout proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_cookie_domain proxy_cookie_path proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_http_version proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_no_cache proxy_pass proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_redirect_errors proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout return rewrite root rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy satisfy_any secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server server_name server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set set_real_ip_from smtp_auth smtp_capabilities so_keepalive source_charset split_clients ssi ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush timeout timer_resolution try_files types types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn upstream use user userid userid_domain userid_expires userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending working_directory xclient xml_entities xslt_entities xslt_stylesheet xslt_types&lt;/Keywords&gt; &lt;/KeywordLists&gt; &lt;Styles&gt; &lt;WordsStyle name=&quot;DEFAULT&quot; styleID=&quot;11&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;FOLDEROPEN&quot; styleID=&quot;12&quot; fgColor=&quot;0000AA&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;1&quot; /&gt; &lt;WordsStyle name=&quot;FOLDERCLOSE&quot; styleID=&quot;13&quot; fgColor=&quot;0000AA&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;1&quot; /&gt; &lt;WordsStyle name=&quot;KEYWORD1&quot; styleID=&quot;5&quot; fgColor=&quot;AA00AA&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;KEYWORD2&quot; styleID=&quot;6&quot; fgColor=&quot;0000FF&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;1&quot; /&gt; &lt;WordsStyle name=&quot;KEYWORD3&quot; styleID=&quot;7&quot; fgColor=&quot;0000AA&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;1&quot; /&gt; &lt;WordsStyle name=&quot;KEYWORD4&quot; styleID=&quot;8&quot; fgColor=&quot;AA0000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;COMMENT&quot; styleID=&quot;1&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;0&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;COMMENT LINE&quot; styleID=&quot;2&quot; fgColor=&quot;AAAAAA&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;1&quot; fontName=&quot;&quot; fontStyle=&quot;2&quot; /&gt; &lt;WordsStyle name=&quot;NUMBER&quot; styleID=&quot;4&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;0&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;OPERATOR&quot; styleID=&quot;10&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;0&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;DELIMINER1&quot; styleID=&quot;14&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;0&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;DELIMINER2&quot; styleID=&quot;15&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; colorStyle=&quot;0&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;WordsStyle name=&quot;DELIMINER3&quot; styleID=&quot;16&quot; fgColor=&quot;000000&quot; bgColor=&quot;FFFFFF&quot; fontName=&quot;&quot; fontStyle=&quot;0&quot; /&gt; &lt;/Styles&gt; &lt;/UserLang&gt;&lt;/NotepadPlus&gt;","categories":[],"tags":[]},{"title":"Mybatis 插入 DATE 只有年月日","slug":"yuque/Mybatis 插入 DATE 只有年月日","date":"2019-12-23T05:43:19.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/23/yuque/Mybatis 插入 DATE 只有年月日/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/23/yuque/Mybatis%20%E6%8F%92%E5%85%A5%20DATE%20%E5%8F%AA%E6%9C%89%E5%B9%B4%E6%9C%88%E6%97%A5/","excerpt":"问题描述在使用 Insert 插入数据到 Oracle 中时，对于 java.util.Date 类型数据，只会记录年月日，丢失了时分秒。","text":"问题描述在使用 Insert 插入数据到 Oracle 中时，对于 java.util.Date 类型数据，只会记录年月日，丢失了时分秒。 原因分析在插入数据时指定了 Date 类型的 JDBC 类型为 DATE，其在向 Oracle 插入数据时，会默认调用 DateOnlyTypeHandler 处理 DATE 类型的日期，转化 Java 类型到 Sql 格式。 1#&#123;updateTime,jdbcType=DATE&#125; Mybatis 通过 TypeHandlerRegistry 注册 Java 类型与 JDBC 类型之间的映射关系： 123456789101112// java 类型为 Date.class，不指定 jdbc 类型，则默认使用 DateTypeHandlerregister(Date.class, new DateTypeHandler());// java 类型为 Date.class，jdbc 类型为 DATE，则默认使用 DateOnlyTypeHandlerregister(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());// java 类型为 Date.class，jdbc 类型为 TIME，则默认使用 DateOnlyTypeHandlerregister(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());// 不指定 java 类型，jdbc 类型为 TIMESTAMP，则默认使用 DateTypeHandlerregister(JdbcType.TIMESTAMP, new DateTypeHandler());// 不指定 java 类型，jdbc 类型为 DATE，则默认使用 DateOnlyTypeHandlerregister(JdbcType.DATE, new DateOnlyTypeHandler());// 不指定 java 类型，jdbc 类型为 TIME，则默认使用 DateOnlyTypeHandlerregister(JdbcType.TIME, new TimeOnlyTypeHandler()); 在 DateOnlyTypeHandler 中，使用了 java.sql.Date 设置时间，该日期格式只会精确到年月日。 1234public void setNonNullParameter(PreparedStatement ps, int i, Date parameter, JdbcType jdbcType) throws SQLException &#123; ps.setDate(i, new java.sql.Date((parameter.getTime()))); &#125; 解决方案参考 TypeHandlerRegistry 中的映射关系可以得出以下解决方案： 不指定 JDBC 类型； 指定 JDBC 类型为 TIMESTAMP； 指定 typeHandler 为 org.apache.ibatis.type.DateTypeHandler（需要写全处理器的限定名），且指定处理优先级最高。","categories":[],"tags":[]},{"title":"Spring 服务端推送（SSE）","slug":"yuque/Spring 服务端推送（SSE）","date":"2019-12-20T03:32:56.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/20/yuque/Spring 服务端推送（SSE）/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/20/yuque/Spring%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81%EF%BC%88SSE%EF%BC%89/","excerpt":"什么是 SSESSE 全程 server-sent event，即服务端推送事件，是服务端到客户端的单向半双工通信技术，适用于服务器向客户端推送实时信息，但是传输量小，且只支持 UTF-8 的编码 key-value 格式的文本数据流，不能传输二进制流。","text":"什么是 SSESSE 全程 server-sent event，即服务端推送事件，是服务端到客户端的单向半双工通信技术，适用于服务器向客户端推送实时信息，但是传输量小，且只支持 UTF-8 的编码 key-value 格式的文本数据流，不能传输二进制流。 代码实现使用 Spring 提供的 SseEmitter 封装类，每隔 2s 向客户端推送一次数据，共推送 5 次。 123456789101112131415161718@GetMapping(&quot;/emitter&quot;) public SseEmitter sseEmitter() &#123; SseEmitter sseEmitter = new SseEmitter(0L); taskExecutor.execute(() -&gt; &#123; for (int i = 1; i &lt; 6; i++) &#123; try &#123; sseEmitter.send(&quot;第&quot; + i + &quot;次发送&quot;); log.info(&quot;第 &#123;&#125; 次发送&quot;, i); Thread.sleep(1000 * 2); &#125; catch (IOException | InterruptedException e) &#123; log.error(&quot;发生异常了: &#123;&#125;&quot;, e.getMessage()); sseEmitter.completeWithError(e); &#125; &#125; sseEmitter.complete(); &#125;); return sseEmitter; &#125; 访问效果 注意事项 接口中直接返回 SseEmitter 对象，推送事件需要在异步线程中执行。 若使用 Nginx 代理接口，需要配置 proxy_buffering off; 关闭代理的缓冲流，使得后端推送的数据可以实时刷新。 SSE 是 HTTP 长连接，需要在连接超时之前推送信息，若无有效推送，可以设置一个标记字符作为维持连接的心跳支持。","categories":[],"tags":[]},{"title":"Spring 自定义线程池","slug":"yuque/Spring 自定义线程池","date":"2019-12-19T05:52:29.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/19/yuque/Spring 自定义线程池/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/19/yuque/Spring%20%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"目的Spring 本身的线程池很简单，每次用到线程都会开辟一个新的线程，效率不高，因此创建一个健壮的线程池，尽量重用现用线程，减少对象创建、消亡的开销是很有必要的。","text":"目的Spring 本身的线程池很简单，每次用到线程都会开辟一个新的线程，效率不高，因此创建一个健壮的线程池，尽量重用现用线程，减少对象创建、消亡的开销是很有必要的。 实现1234567891011121314151617181920212223242526272829303132333435363738394041@Slf4j@Configuration@ConfigurationProperties(prefix = &quot;task.pool&quot;)@Setter@EnableAsyncpublic class TaskExecutorConfig &#123; /** * 核心线程池大小 */ private int corePoolSize; /** * 最大线程池大小 */ private int maxPoolSize; /** * 活跃时间 */ private int keepAliveSeconds; /** * 队列容量 */ private int queueCapacity; @Bean public ThreadPoolTaskExecutor taskExecutorPool() &#123; // 标记此处-1，下方会使用匿名类对原生线程池进行拓展 ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setKeepAliveSeconds(keepAliveSeconds); executor.setQueueCapacity(queueCapacity);// 当线程池达到最大时，不再开启新线程，使用调用者所在线程执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; 分析1、添加 Spring 配置使用类配置注解，并设置前缀，这样在对象的成员变量会自动注入 spring 的配置文件中的键值对。 123@Configuration@ConfigurationProperties(prefix = &quot;executor.pool&quot;)@Setter 对应的配置文件，当然需要使用 setter 方法进行赋值： 123456executor: pool: core-pool-size: 20 max-pool-size: 40 keep-alive-seconds: 300 queue-capacity: 50 需要的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 2、开启异步支持使用 @EnableAsync 注解，也可以在启动类上添加。全局只要一个即可开启异步。 1@EnableAsync 使用交由 Spring 托管，直接使用依赖注入，注入名称默认为 @Bean 标记的方法名。 1234@Resource(name = &quot;taskExecutorPool&quot;) private ThreadPoolTaskExecutor taskExecutor;// 或@Async(&quot;taskExecutorPool&quot;) 拓展配置当前线程在执行或提交时，不会显示的打印出线程池状态，为了实现这一点，此处通过匿名子类的方式拓展 spring#ThreadPoolTaskExecutor。自然，单独实现子类也可以达成效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 此处代码对应上方标记-1ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor() &#123; private void showThreadPoolInfo(String prefix)&#123; ThreadPoolExecutor threadPoolExecutor = getThreadPoolExecutor(); log.info(&quot;&#123;&#125;&#123;&#125;,线程数: [&#123;&#125;], 已完成线程数: [&#123;&#125;], 活跃线程数: [&#123;&#125;], 队列大小: [&#123;&#125;]&quot;, this.getThreadNamePrefix(), prefix, threadPoolExecutor.getTaskCount(), threadPoolExecutor.getCompletedTaskCount(), threadPoolExecutor.getActiveCount(), threadPoolExecutor.getQueue().size()); &#125; @Override public void execute(Runnable task) &#123; showThreadPoolInfo(&quot;执行线程&quot;); super.execute(task); &#125; // 该方法可忽略，源码中并未使用 startTimeout 参数，直接调用 execute(task) @Override public void execute(Runnable task, long startTimeout) &#123; showThreadPoolInfo(&quot;执行线程&quot;); super.execute(task, startTimeout); &#125; @Override public Future&lt;?&gt; submit(Runnable task) &#123; showThreadPoolInfo(&quot;提交线程&quot;); return super.submit(task); &#125; @Override public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; showThreadPoolInfo(&quot;提交线程&quot;); return super.submit(task); &#125; @Override public ListenableFuture&lt;?&gt; submitListenable(Runnable task) &#123; showThreadPoolInfo(&quot;提交监听&quot;); return super.submitListenable(task); &#125; @Override public &lt;T&gt; ListenableFuture&lt;T&gt; submitListenable(Callable&lt;T&gt; task) &#123; showThreadPoolInfo(&quot;提交监听&quot;); return super.submitListenable(task); &#125; &#125;;","categories":[],"tags":[]},{"title":"Async 注解 - 异步调用测试","slug":"yuque/Async 注解 - 异步调用测试","date":"2019-12-18T03:20:53.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/18/yuque/Async 注解 - 异步调用测试/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/18/yuque/Async%20%E6%B3%A8%E8%A7%A3%20-%20%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%B5%8B%E8%AF%95/","excerpt":"什么是异步调用程序将启用异步调用的操作交由独立线程执行，跳过等待异步调用返回结果，继续往下执行。","text":"什么是异步调用程序将启用异步调用的操作交由独立线程执行，跳过等待异步调用返回结果，继续往下执行。 如何启用异步调用 在 Spring 的启动类（或配置类）上添加 @EnableAsync 开启异步操作支持； 在需要执行异步的方法上添加 @Async 注解，标记其为异步方法； 如何处理异步方法的返回结果 在异步方法中使用 Future 封装返回值，表示其为异步结果，但实际返回时需要使用 AsyncResult 类型，Future 是其顶级接口； 在异步调用时，当主程序需要调用异步结果时，必须进行自我阻塞（通常使用循环等待异步操作），直到异步方法完成，否则异步结果会丢失； 测试代码 配置启动类，开启异步支持。 1234567// 忽略其他注解@EnableAsyncpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建一个异步方法，该方法接收字符串与秒数，执行后会在睡眠指定时间之后返回字符串。 1234567891011// AsyncService.class@Async public Future&lt;String&gt; stringFuture(String str, long time) &#123; try &#123; Thread.sleep(time * 1000); return new AsyncResult&lt;&gt;(str); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null; &#125; 创建一个测试方法，该方法调用了上步创建的异步方法，并指定其睡眠 15s 后返回 “hello future” 字符串，且会在等待异步结果时每秒打印一次等待时间。 1234567891011121314151617181920212223// AsyncServiceTest.class@Test public void futureString() &#123; long begin = System.currentTimeMillis(); Future&lt;String&gt; future = asyncService.stringFuture(&quot;hello future&quot;, 15); while (true) &#123; if (future.isDone()) &#123; try &#123; log.info(&quot;future result: &#123;&#125;&quot;, future.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; break; &#125; try &#123; log.info(&quot;已用时：&#123;&#125;ms&quot;, System.currentTimeMillis() - begin); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; log.info(&quot;futureString 共耗时：&#123;&#125;ms&quot;, System.currentTimeMillis() - begin); &#125; 结果如预期一致，异步结果在等待 15s 后成功打印字符串，并每隔一秒打印等待时间。 123456789101112131415161718c.example.test.service.AsyncServiceTest : 已用时：8msc.example.test.service.AsyncServiceTest : 已用时：1010msc.example.test.service.AsyncServiceTest : 已用时：2010msc.example.test.service.AsyncServiceTest : 已用时：3011msc.example.test.service.AsyncServiceTest : 已用时：4011msc.example.test.service.AsyncServiceTest : 已用时：5012msc.example.test.service.AsyncServiceTest : 已用时：6013msc.example.test.service.AsyncServiceTest : 已用时：7013msc.example.test.service.AsyncServiceTest : 已用时：8013msc.example.test.service.AsyncServiceTest : 已用时：9014msc.example.test.service.AsyncServiceTest : 已用时：10014msc.example.test.service.AsyncServiceTest : 已用时：11015msc.example.test.service.AsyncServiceTest : 已用时：12015msc.example.test.service.AsyncServiceTest : 已用时：13015msc.example.test.service.AsyncServiceTest : 已用时：14016msc.example.test.service.AsyncServiceTest : future result: hello futurec.example.test.service.AsyncServiceTest : futureString 共耗时：15017ms 取消启动类上的 @EnableAsync 注解，对比执行结果。 123456// @EnableAsyncpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 发现主程序中并未在每秒间隔时间中打印等待时间，即在执行循环时，已经等待 15s，证明没有启用异步调用的程序被阻塞了。 12c.example.test.service.AsyncServiceTest : future result: hello futurec.example.test.service.AsyncServiceTest : futureString 共耗时：15003ms 测试时不使用循环等待异步结果。 123456789101112131415// AsyncServiceTest.class@Test public void futureStringWithoutLoop() &#123; log.info(&quot;无循环接收 future 结果测试&quot;); long begin = System.currentTimeMillis(); Future&lt;String&gt; future = asyncService.stringFuture(&quot;hello future&quot;, 15); if (future.isDone()) &#123; try &#123; log.info(&quot;future result: &#123;&#125;&quot;, future.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; log.info(&quot;futureString 共耗时：&#123;&#125;ms&quot;, System.currentTimeMillis() - begin); &#125; 主程序执行时直接跳过异步方法，且未能接收到异步结果，证明异步方法尽管可以使得程序并行操作，但是在最后接收结果时仍需使用循环进行自我阻塞等待异步结果，执行总时长应为 Max(主程序耗时，异步方法耗时)。 12c.example.test.service.AsyncServiceTest : 无循环接收 future 结果测试c.example.test.service.AsyncServiceTest : futureString 共耗时：41ms 注意事项 此处使用的 Future 接口接收异步结果，该是异步阻塞接口； 建议不使用无返回值异步方法，否则内部产生异常不会被感知； @Async 可以通过注解属性指定线程池，默认使用 SimpleAsyncTaskExecutor； 专有配置类通过实现 AsyncConfigurer 接口可以指定 @Async 的默认线程池，即无需通过注解属性显示指定。此处通过直接注入自定义线程池进行配置 @Async，亦可在该配置类中直接创建线程池，即 new ThreadPoolTaskExecutor() ，并载入配置信息，可参考《Spring 自定义线程池》。 123456789101112131415161718@Setter@Slf4j@Componentpublic class AsyncTaskExecutorConfig implements AsyncConfigurer &#123; @Resource(name = &quot;taskExecutorPool&quot;) private ThreadPoolTaskExecutor executor; @Override public Executor getAsyncExecutor() &#123; return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return (throwable, method, objects) -&gt; log.error(&quot;异常信息: &#123;&#125;, 异常方法: &#123;&#125;&quot;, throwable.getMessage(), method.getName()); &#125;&#125;","categories":[],"tags":[]},{"title":"学习计划","slug":"yuque/学习计划","date":"2019-12-17T16:35:21.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/18/yuque/学习计划/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/18/yuque/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/","excerpt":"学习重点插入「脑图」并进行编辑","text":"学习重点插入「脑图」并进行编辑 学习资源课堂 PPT嵌入「本地文件」，在文档中可预览此文件： 脑图（XMind、Mind Manager、Mind Node）设计文件（PhotoShop、Sketch、Axure)办公文件（PDF、PPT、Word、Excel、Keynote、Pages、Numbers） 教学视频嵌入「本地视频」或「在线视频」，如优酷及 Bilibili 视频： 阅读材料插入「附件」 示例 PDF.pdf 学习计划插入「表格」，可以在表格框里插入对应的图片、附件、状态 书名 章节 计划阅读时间 进程 《基础有机化学》 第三章 2h 已完成 《无机化学》 第一章 1h 进行中 《物理化学》 第四章 1h 未开始","categories":[],"tags":[]},{"title":"读书笔记","slug":"yuque/读书笔记","date":"2019-12-17T16:35:21.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/18/yuque/读书笔记/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/18/yuque/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"插入封面图片，点击图片，设置图片大小","text":"插入封面图片，点击图片，设置图片大小 关于本书插入「表格」 书名 《菊次郎与佐纪》 作者 北野武日本 出版社 译林出版社 阅读日期 2019 年 2 月 豆瓣评分 8.1 我的评分 ☆☆☆☆ 内容简介在此处输入文本你将读到的是北野武的出身、父母、兄弟和家庭的故事。但请放心，这绝非一个自我感觉良好的人写的那种“优良课外读物”。相反，北野武用搞笑到甚至刻薄方式描绘这些人和事，让我们在笑与泪的交织中，看到真情和真实，看到那么多情、柔软的心。 书摘在此处输入文本 你将读到的是北野武的出身、父母、兄弟和家庭的故事。 但请放心，这绝非一个自我感觉良好的人写的那种“优良课外读物”。很喜欢这句 ← 方便打标签的状态卡片 相反，北野武用搞笑到甚至刻薄方式描绘这些人和事，让我们在笑与泪的交织中，看到真情和真实，看到那么多情、柔软的心。 读后感在此处输入文本 你将读到的是北野武的出身、父母、兄弟和家庭的故事。 但请放心，这绝非一个自我感觉良好的人写的那种“优良课外读物”。 相反，北野武用搞笑到甚至刻薄方式描绘这些人和事，让我们在笑与泪的交织中，看到真情和真实，看到那么多情、柔软的心。","categories":[],"tags":[]},{"title":"Nginx 转发接口导致超时解决方案","slug":"yuque/Nginx 转发接口导致超时解决方案","date":"2019-12-17T15:54:20.000Z","updated":"2022-03-03T15:43:10.552Z","comments":true,"path":"2019/12/17/yuque/Nginx 转发接口导致超时解决方案/","link":"","permalink":"http://daiwenzh5.github.io/2019/12/17/yuque/Nginx%20%E8%BD%AC%E5%8F%91%E6%8E%A5%E5%8F%A3%E5%AF%BC%E8%87%B4%E8%B6%85%E6%97%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"问题描述生产环境在导出 Excel 时出现连接超时，将数据复制到测试环境，使用本地项目测试时，能够顺利执行。","text":"问题描述生产环境在导出 Excel 时出现连接超时，将数据复制到测试环境，使用本地项目测试时，能够顺利执行。 环境差异生产环境使用 Nginx 代理接口，而本地项目没有使用，将本地启用 Nginx 之后，同样出现超时现象。 原因总结Nginx 限制了转发 Http 请求的连接时间。 解决方案一、修改 Nginx 转发模块的超时时间在 Nginx 对应的转发模块下添加 proxy_read_timeout 属性。 1234567891011proxy_read_timeout 300;### 其粒度可以控制在 location、server、http 中，优先级逐次减小，即最外层优先级最低http &#123; proxy_read_timeout 10; server &#123; proxy_read_timeout 60; location / &#123; proxy_read_timeout 300; &#125; &#125;&#125; 属性说明在实际表现中，proxy_read_timeout 的时间值为实际超时时间的一半，即假定转发模块的读取超时时间为 60s，使用 Postman 访问时的超时时间为 120s 左右。 相关属性 proxy_connect_timeout : 后端服务器连接的超时时间，发起握手等候响应超时时间； proxy_read_timeout: 连接成功后，等候后端服务器响应时间，其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间，后端的耗时操作主要占用此时期）； proxy_send_timeout : 后端服务器数据回传时间，在规定时间之内后端服务器必须传完所有的数据； 二、后端采用异步任务将耗时操作放置在 @Async 标记的方法中，返回 Future 包裹的处理结果，一旦其处理完成，则使用 SSE 推送到前端。 问题：无法避免配置超时时间属性需要注意的是，在使用 SSE 推送时，必须定期返回响应，若超过 Nginx 的最大读取超时时间（proxy_read_timeout ）仍无响应，则依然会出现超时现象。 解决只需在超时之前返回心态标记维持连接，前端忽略标记字符即可。","categories":[],"tags":[]}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/"},{"name":"Rest Template","slug":"Spring-Boot/Rest-Template","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/Rest-Template/"},{"name":"Unit Test","slug":"Spring-Boot/Unit-Test","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/Unit-Test/"},{"name":"Vue3","slug":"Vue3","permalink":"http://daiwenzh5.github.io/categories/Vue3/"},{"name":"异常","slug":"Vue3/异常","permalink":"http://daiwenzh5.github.io/categories/Vue3/%E5%BC%82%E5%B8%B8/"},{"name":"Spring","slug":"Spring","permalink":"http://daiwenzh5.github.io/categories/Spring/"},{"name":"参数校验","slug":"Spring/参数校验","permalink":"http://daiwenzh5.github.io/categories/Spring/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"name":"微服务","slug":"微服务","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Spring Cloud","slug":"微服务/Spring-Cloud","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Spring-Cloud/"},{"name":"WebFilter","slug":"Spring-Boot/WebFilter","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/WebFilter/"},{"name":"配置文件","slug":"Spring-Boot/配置文件","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"参数处理","slug":"Spring-Boot/参数处理","permalink":"http://daiwenzh5.github.io/categories/Spring-Boot/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/categories/Mybatis/"},{"name":"结果集","slug":"Mybatis/结果集","permalink":"http://daiwenzh5.github.io/categories/Mybatis/%E7%BB%93%E6%9E%9C%E9%9B%86/"},{"name":"缓存","slug":"缓存","permalink":"http://daiwenzh5.github.io/categories/%E7%BC%93%E5%AD%98/"},{"name":"Redis","slug":"缓存/Redis","permalink":"http://daiwenzh5.github.io/categories/%E7%BC%93%E5%AD%98/Redis/"},{"name":"Feign","slug":"Spring/Feign","permalink":"http://daiwenzh5.github.io/categories/Spring/Feign/"},{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"工具/Java","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/Java/"},{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/categories/Maven/"},{"name":"打包","slug":"Maven/打包","permalink":"http://daiwenzh5.github.io/categories/Maven/%E6%89%93%E5%8C%85/"},{"name":"JDK8","slug":"JDK8","permalink":"http://daiwenzh5.github.io/categories/JDK8/"},{"name":"Time","slug":"JDK8/Time","permalink":"http://daiwenzh5.github.io/categories/JDK8/Time/"},{"name":"命令行","slug":"Maven/命令行","permalink":"http://daiwenzh5.github.io/categories/Maven/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"http://daiwenzh5.github.io/categories/Linux/"},{"name":"VPN","slug":"Linux/VPN","permalink":"http://daiwenzh5.github.io/categories/Linux/VPN/"},{"name":"Intellij Plugin","slug":"工具/Intellij-Plugin","permalink":"http://daiwenzh5.github.io/categories/%E5%B7%A5%E5%85%B7/Intellij-Plugin/"},{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://daiwenzh5.github.io/categories/Intellij-Idea/"},{"name":"plugin","slug":"Intellij-Idea/plugin","permalink":"http://daiwenzh5.github.io/categories/Intellij-Idea/plugin/"},{"name":"拦截器","slug":"Mybatis/拦截器","permalink":"http://daiwenzh5.github.io/categories/Mybatis/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"插件","slug":"Maven/插件","permalink":"http://daiwenzh5.github.io/categories/Maven/%E6%8F%92%E4%BB%B6/"},{"name":"maven","slug":"maven","permalink":"http://daiwenzh5.github.io/categories/maven/"},{"name":"聚合项目","slug":"maven/聚合项目","permalink":"http://daiwenzh5.github.io/categories/maven/%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE/"},{"name":"mybatis","slug":"mybatis","permalink":"http://daiwenzh5.github.io/categories/mybatis/"},{"name":"xml","slug":"mybatis/xml","permalink":"http://daiwenzh5.github.io/categories/mybatis/xml/"},{"name":"dubbo","slug":"微服务/dubbo","permalink":"http://daiwenzh5.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo/"},{"name":"Typescript","slug":"Typescript","permalink":"http://daiwenzh5.github.io/categories/Typescript/"},{"name":"装饰器","slug":"Typescript/装饰器","permalink":"http://daiwenzh5.github.io/categories/Typescript/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://daiwenzh5.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Oracle","slug":"数据库/Oracle","permalink":"http://daiwenzh5.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/"},{"name":"边缘技术","slug":"边缘技术","permalink":"http://daiwenzh5.github.io/categories/%E8%BE%B9%E7%BC%98%E6%8A%80%E6%9C%AF/"},{"name":"前端","slug":"边缘技术/前端","permalink":"http://daiwenzh5.github.io/categories/%E8%BE%B9%E7%BC%98%E6%8A%80%E6%9C%AF/%E5%89%8D%E7%AB%AF/"},{"name":"版本控制","slug":"版本控制","permalink":"http://daiwenzh5.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"windows","slug":"版本控制/windows","permalink":"http://daiwenzh5.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/windows/"},{"name":"前端","slug":"前端","permalink":"http://daiwenzh5.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Hexo","slug":"前端/Hexo","permalink":"http://daiwenzh5.github.io/categories/%E5%89%8D%E7%AB%AF/Hexo/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://daiwenzh5.github.io/tags/Spring-Boot/"},{"name":"Rest Template","slug":"Rest-Template","permalink":"http://daiwenzh5.github.io/tags/Rest-Template/"},{"name":"Http 请求","slug":"Http-请求","permalink":"http://daiwenzh5.github.io/tags/Http-%E8%AF%B7%E6%B1%82/"},{"name":"Restful","slug":"Restful","permalink":"http://daiwenzh5.github.io/tags/Restful/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"http://daiwenzh5.github.io/tags/Unit-Test/"},{"name":"MVC","slug":"MVC","permalink":"http://daiwenzh5.github.io/tags/MVC/"},{"name":"Mock","slug":"Mock","permalink":"http://daiwenzh5.github.io/tags/Mock/"},{"name":"Vue3","slug":"Vue3","permalink":"http://daiwenzh5.github.io/tags/Vue3/"},{"name":"Uniapp","slug":"Uniapp","permalink":"http://daiwenzh5.github.io/tags/Uniapp/"},{"name":"async setup","slug":"async-setup","permalink":"http://daiwenzh5.github.io/tags/async-setup/"},{"name":"异常","slug":"异常","permalink":"http://daiwenzh5.github.io/tags/%E5%BC%82%E5%B8%B8/"},{"name":"注解","slug":"注解","permalink":"http://daiwenzh5.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"Spring","slug":"Spring","permalink":"http://daiwenzh5.github.io/tags/Spring/"},{"name":"参数校验","slug":"参数校验","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"},{"name":"自定义","slug":"自定义","permalink":"http://daiwenzh5.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://daiwenzh5.github.io/tags/Spring-Cloud/"},{"name":"Config","slug":"Config","permalink":"http://daiwenzh5.github.io/tags/Config/"},{"name":"微服务","slug":"微服务","permalink":"http://daiwenzh5.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"配置中心","slug":"配置中心","permalink":"http://daiwenzh5.github.io/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"name":"WebFilter","slug":"WebFilter","permalink":"http://daiwenzh5.github.io/tags/WebFilter/"},{"name":"属性失效","slug":"属性失效","permalink":"http://daiwenzh5.github.io/tags/%E5%B1%9E%E6%80%A7%E5%A4%B1%E6%95%88/"},{"name":"urlPatterns","slug":"urlPatterns","permalink":"http://daiwenzh5.github.io/tags/urlPatterns/"},{"name":"配置文件","slug":"配置文件","permalink":"http://daiwenzh5.github.io/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"name":"多环境","slug":"多环境","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%8E%AF%E5%A2%83/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://daiwenzh5.github.io/tags/Bootstrap/"},{"name":"参数处理","slug":"参数处理","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86/"},{"name":"XML","slug":"XML","permalink":"http://daiwenzh5.github.io/tags/XML/"},{"name":"JSON","slug":"JSON","permalink":"http://daiwenzh5.github.io/tags/JSON/"},{"name":"结果集","slug":"结果集","permalink":"http://daiwenzh5.github.io/tags/%E7%BB%93%E6%9E%9C%E9%9B%86/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://daiwenzh5.github.io/tags/Mybatis/"},{"name":"Lombok","slug":"Lombok","permalink":"http://daiwenzh5.github.io/tags/Lombok/"},{"name":"异常分析","slug":"异常分析","permalink":"http://daiwenzh5.github.io/tags/%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"},{"name":"JetCache","slug":"JetCache","permalink":"http://daiwenzh5.github.io/tags/JetCache/"},{"name":"多级缓存","slug":"多级缓存","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"},{"name":"使用","slug":"使用","permalink":"http://daiwenzh5.github.io/tags/%E4%BD%BF%E7%94%A8/"},{"name":"拓展","slug":"拓展","permalink":"http://daiwenzh5.github.io/tags/%E6%8B%93%E5%B1%95/"},{"name":"Feign","slug":"Feign","permalink":"http://daiwenzh5.github.io/tags/Feign/"},{"name":"Configuration","slug":"Configuration","permalink":"http://daiwenzh5.github.io/tags/Configuration/"},{"name":"HTTP","slug":"HTTP","permalink":"http://daiwenzh5.github.io/tags/HTTP/"},{"name":"拦截器","slug":"拦截器","permalink":"http://daiwenzh5.github.io/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"工具","slug":"工具","permalink":"http://daiwenzh5.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Java","slug":"Java","permalink":"http://daiwenzh5.github.io/tags/Java/"},{"name":"Jar 冲突","slug":"Jar-冲突","permalink":"http://daiwenzh5.github.io/tags/Jar-%E5%86%B2%E7%AA%81/"},{"name":"多版本","slug":"多版本","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"},{"name":"Maven","slug":"Maven","permalink":"http://daiwenzh5.github.io/tags/Maven/"},{"name":"Lib","slug":"Lib","permalink":"http://daiwenzh5.github.io/tags/Lib/"},{"name":"Install","slug":"Install","permalink":"http://daiwenzh5.github.io/tags/Install/"},{"name":"外部依赖","slug":"外部依赖","permalink":"http://daiwenzh5.github.io/tags/%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96/"},{"name":"JDK8","slug":"JDK8","permalink":"http://daiwenzh5.github.io/tags/JDK8/"},{"name":"Time","slug":"Time","permalink":"http://daiwenzh5.github.io/tags/Time/"},{"name":"LocalDate","slug":"LocalDate","permalink":"http://daiwenzh5.github.io/tags/LocalDate/"},{"name":"日期格式化","slug":"日期格式化","permalink":"http://daiwenzh5.github.io/tags/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"},{"name":"Deploy","slug":"Deploy","permalink":"http://daiwenzh5.github.io/tags/Deploy/"},{"name":"Idea","slug":"Idea","permalink":"http://daiwenzh5.github.io/tags/Idea/"},{"name":"命令行","slug":"命令行","permalink":"http://daiwenzh5.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"http://daiwenzh5.github.io/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"http://daiwenzh5.github.io/tags/Centos/"},{"name":"VPN","slug":"VPN","permalink":"http://daiwenzh5.github.io/tags/VPN/"},{"name":"OpenConnect","slug":"OpenConnect","permalink":"http://daiwenzh5.github.io/tags/OpenConnect/"},{"name":"Intellij Plugin","slug":"Intellij-Plugin","permalink":"http://daiwenzh5.github.io/tags/Intellij-Plugin/"},{"name":"运维","slug":"运维","permalink":"http://daiwenzh5.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"自动部署","slug":"自动部署","permalink":"http://daiwenzh5.github.io/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"name":"Intellij Idea","slug":"Intellij-Idea","permalink":"http://daiwenzh5.github.io/tags/Intellij-Idea/"},{"name":"plugin","slug":"plugin","permalink":"http://daiwenzh5.github.io/tags/plugin/"},{"name":"swing","slug":"swing","permalink":"http://daiwenzh5.github.io/tags/swing/"},{"name":"java","slug":"java","permalink":"http://daiwenzh5.github.io/tags/java/"},{"name":"ResultMap","slug":"ResultMap","permalink":"http://daiwenzh5.github.io/tags/ResultMap/"},{"name":"插件","slug":"插件","permalink":"http://daiwenzh5.github.io/tags/%E6%8F%92%E4%BB%B6/"},{"name":"发版","slug":"发版","permalink":"http://daiwenzh5.github.io/tags/%E5%8F%91%E7%89%88/"},{"name":"Tag","slug":"Tag","permalink":"http://daiwenzh5.github.io/tags/Tag/"},{"name":"maven","slug":"maven","permalink":"http://daiwenzh5.github.io/tags/maven/"},{"name":"聚合项目","slug":"聚合项目","permalink":"http://daiwenzh5.github.io/tags/%E8%81%9A%E5%90%88%E9%A1%B9%E7%9B%AE/"},{"name":"版本更新","slug":"版本更新","permalink":"http://daiwenzh5.github.io/tags/%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/"},{"name":"version","slug":"version","permalink":"http://daiwenzh5.github.io/tags/version/"},{"name":"mybatis","slug":"mybatis","permalink":"http://daiwenzh5.github.io/tags/mybatis/"},{"name":"xml","slug":"xml","permalink":"http://daiwenzh5.github.io/tags/xml/"},{"name":"insert","slug":"insert","permalink":"http://daiwenzh5.github.io/tags/insert/"},{"name":"主键","slug":"主键","permalink":"http://daiwenzh5.github.io/tags/%E4%B8%BB%E9%94%AE/"},{"name":"dubbo","slug":"dubbo","permalink":"http://daiwenzh5.github.io/tags/dubbo/"},{"name":"springboot","slug":"springboot","permalink":"http://daiwenzh5.github.io/tags/springboot/"},{"name":"踩坑日记","slug":"踩坑日记","permalink":"http://daiwenzh5.github.io/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"},{"name":"Typescript","slug":"Typescript","permalink":"http://daiwenzh5.github.io/tags/Typescript/"},{"name":"Javascript","slug":"Javascript","permalink":"http://daiwenzh5.github.io/tags/Javascript/"},{"name":"装饰器","slug":"装饰器","permalink":"http://daiwenzh5.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"name":"oracle","slug":"oracle","permalink":"http://daiwenzh5.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://daiwenzh5.github.io/tags/sql/"},{"name":"hexo","slug":"hexo","permalink":"http://daiwenzh5.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://daiwenzh5.github.io/tags/blog/"},{"name":"excerpt","slug":"excerpt","permalink":"http://daiwenzh5.github.io/tags/excerpt/"},{"name":"语雀编辑器","slug":"语雀编辑器","permalink":"http://daiwenzh5.github.io/tags/%E8%AF%AD%E9%9B%80%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"git","slug":"git","permalink":"http://daiwenzh5.github.io/tags/git/"},{"name":"windows","slug":"windows","permalink":"http://daiwenzh5.github.io/tags/windows/"},{"name":"Hexo","slug":"Hexo","permalink":"http://daiwenzh5.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://daiwenzh5.github.io/tags/Blog/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://daiwenzh5.github.io/tags/Github-Pages/"},{"name":"语雀","slug":"语雀","permalink":"http://daiwenzh5.github.io/tags/%E8%AF%AD%E9%9B%80/"}]}